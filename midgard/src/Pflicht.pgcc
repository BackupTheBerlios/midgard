#include "Pflicht.hh"
#include <Aux/SQLerror.h>
#include <Aux/Transaction.h>
exec sql include sqlca;
#include <gtk--/main.h>


/*
cH_Pflicht::cache_t cH_Pflicht::cache;

cH_Pflicht::cH_Pflicht(const std::string& spezies,const vector<H_Data_typen>& Typ)
{
 st_index index(spezies,Typ);
 cH_Pflicht *cached(cache.lookup(index));
 if (cached) *this=*cached;
 else
  {
   *this=cH_Pflicht(new Pflicht(spezies,Typ));
   cache.Register(index,*this);
  }
}
*/

Pflicht::Pflicht(Gtk::ProgressBar *progressbar)//const std::string& spezies,const vector<H_Data_typen>& Typ)
{
  exec sql begin declare section;
   char TYP[50],PFLICHT[50],VERBOTEN[50];
   int LERNPUNKTE,ERFOLGSWERT;
   char SPIELBEGINN[10];
   char query[1024];
   int db_size;
  exec sql end declare section; 
  exec sql select count(typ) into :db_size from pflicht_lernen;
  std::string squery="select typ, coalesce(pflicht,''), coalesce(lernpunkte,0),
      coalesce(verboten,''),coalesce(spielbegin,''),coalesce(erfolgswert,0)
      from pflicht_lernen order by typ";
      
  strncpy(query,squery.c_str(),sizeof(query));
  Transaction tr;
  exec sql prepare cl_pflicht_ein_ from :query ;
  exec sql declare cl_pflicht_ein cursor for cl_pflicht_ein_ ;

  exec sql open cl_pflicht_ein;
  SQLerror::test(__FILELINE__);
  std::list<pf> list_pflicht;
  std::string typmem="";
  double count=0;
  while (true)
   {
     progressbar->set_percentage(count/db_size);
     while(Gtk::Main::events_pending()) Gtk::Main::iteration() ;
     exec sql fetch cl_pflicht_ein into :TYP, :PFLICHT, :LERNPUNKTE, :VERBOTEN,
         :SPIELBEGINN,:ERFOLGSWERT;
     SQLerror::test(__FILELINE__,100);
     if (sqlca.sqlcode) break;
     if(typmem==std::string(TYP) || typmem=="")
      {
        list_pflicht.push_back(pf(PFLICHT,VERBOTEN,LERNPUNKTE,ERFOLGSWERT,SPIELBEGINN));
      }      
     else
      {
        pflicht_map[TYP] = list_pflicht;
        list_pflicht.clear();
      }
     typmem=TYP;
     ++count;
   }
 exec sql close cl_pflicht_ein;
 tr.close();
 progressbar->set_percentage(1);
}

int Pflicht::istPflicht(const std::string& spezies,const vector<H_Data_typen>& Typ,
                        const std::string& name,LE le) const
{
  assert (Typ.size()==2);
  std::list<pf> list_pflicht   = const_cast<map<std::string,list<pf> > &>(pflicht_map)[spezies];
  std::list<pf> list_pflicht_2 = const_cast<map<std::string,list<pf> > &>(pflicht_map)[Typ[0]->Short()];
  std::list<pf> list_pflicht_3 = const_cast<map<std::string,list<pf> > &>(pflicht_map)[Typ[1]->Short()];
  list_pflicht.merge(list_pflicht_2);
  list_pflicht.merge(list_pflicht_3);
  for(std::list<pf>::const_iterator i=list_pflicht.begin();i!=list_pflicht.end();++i)
   if(i->pflicht==name) 
      { if (le==LERNPUNKTE)  return  i->lernpunkte;
        if (le==ERFOLGSWERT) return i->erfolgswert;
      }
  return 0; 
}

bool Pflicht::istVerboten(const std::string& spezies,const vector<H_Data_typen>& Typ,
                          const std::string& name,bool spielbeginn) const
{
  assert (Typ.size()==2);
  std::list<pf> list_pflicht =   const_cast<map<std::string,list<pf> > &>(pflicht_map)[spezies];
  std::list<pf> list_pflicht_2 = const_cast<map<std::string,list<pf> > &>(pflicht_map)[Typ[0]->Short()];
  std::list<pf> list_pflicht_3 = const_cast<map<std::string,list<pf> > &>(pflicht_map)[Typ[1]->Short()];
  list_pflicht.merge(list_pflicht_2);
  list_pflicht.merge(list_pflicht_3);
  for(std::list<pf>::const_iterator i=list_pflicht.begin();i!=list_pflicht.end();++i)
   {  if(spielbeginn && i->verboten==name && i->spielbeginn!="") return true;
      if(i->verboten==name) return true;
   }
  return false; 
}


