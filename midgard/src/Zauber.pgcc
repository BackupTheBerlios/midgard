#include "Zauber.hh"
#include "midgard_CG.hh"
#include <Aux/SQLerror.h>
#include <Aux/Transaction.h>
#include "class_typen.hh"
exec sql include sqlca;

cH_Zauber::cache_t cH_Zauber::cache;

cH_Zauber::cH_Zauber(const std::string& name,int lernpunkte=0)
{
 st_index index(name,lernpunkte);
 cH_Zauber *cached(cache.lookup(index));
 if (cached) *this=*cached;
 else
  {
   *this=cH_Zauber(new Zauber(name,lernpunkte));
   cache.Register(index,*this);
  }
}

void Zauber::get_Zauber()
{
  exec sql begin declare section;
   char db_ursprung[50];
   int db_kosten;
   char db_stufe[10];
   char db_spruchrolle[10];
   char query[1000];
   char db_region[10];
   char db_zauberart[30];
   char db_p_element[30],db_s_element[30];
   char db_ap[10], db_art[20], db_agens[30], db_prozess[30], 
        db_reagens[30], db_zauberdauer[30], db_reichweite[10],
        db_wirkungsziel[30], db_wirkungsbereich[30], db_wirkungsdauer[20], 
        db_material[50], db_thaumagram[10], db_effekt[1024];
  exec sql end declare section;
//   char db_standard[20],db_standard2[20];
//  strncpy(db_standard2,"",sizeof(db_standard2));
  
  std::string squery = "SELECT coalesce(z.ursprung,''), 
      z.kosten, z.stufe, coalesce(z.spruchrolle,''), coalesce(z.region,''), 
      coalesce(z.zauberart,''),coalesce(z.p_element,''), 
      coalesce(z.s_element,''), z.ap, z.art, coalesce(z.agens,''),
      coalesce(z.prozess,''), coalesce(z.reagens,''),z.zauberdauer,
      z.reichweite,z.wirkungsziel,z.wirkungsbereich,
      z.wirkungsdauer,coalesce(z.material),coalesce(z.thaumagram,''),coalesce(z.effekt,'')
      FROM arkanum_zauber z
      WHERE name = '"+name+"'";
   strncpy(query,squery.c_str(),sizeof(query));
   Transaction tr;
   exec sql prepare cl_zauber_ein_ from :query ;
   exec sql declare cl_zauber_ein cursor for cl_zauber_ein_ ;

//cout << query<<'\n';
   exec sql open cl_zauber_ein;
   SQLerror::test(__FILELINE__);
   exec sql fetch cl_zauber_ein into :db_ursprung, :db_kosten,
      :db_stufe,  :db_spruchrolle, :db_region, :db_zauberart,
      :db_p_element, :db_s_element, :db_ap, :db_art, :db_agens,
      :db_prozess, :db_reagens, :db_zauberdauer, :db_reichweite,
      :db_wirkungsziel, :db_wirkungsbereich, :db_wirkungsdauer, 
      :db_material, :db_thaumagram, :db_effekt;
   SQLerror::test(__FILELINE__);

   ursprung=db_ursprung;   
   kosten=db_kosten;
   stufe=db_stufe;
   spruchrolle=db_spruchrolle;
   region=db_region;
   zauberart=db_zauberart;
   p_element=db_p_element;
   s_element=db_s_element;
   ap=db_ap;
   art=db_art;
   stufe=db_stufe;
   zauberdauer=db_zauberdauer;
   reichweite=db_reichweite;
   wirkungsziel=db_wirkungsziel;
   wirkungsbereich=db_wirkungsbereich;
   wirkungsdauer=db_wirkungsdauer;
   ursprung=db_ursprung;
   material=db_material;
   agens=db_agens;
   prozess=db_prozess;
   reagens=db_reagens;
   beschreibung=db_effekt;
   exec sql close cl_zauber_ein;
   tr.close();
}

/*
void Zauber::get_map_typ()
{
 exec sql begin declare section;
   char query[1024], db_typ[10], db_standard[10];
 exec sql end declare section;
 std::string squery ="select typ,standard from zauber_typen where name ='"+Name()+"'";
 strncpy(query,squery.c_str(),sizeof(query));
 Transaction tr;
 exec sql prepare ZTein_ from :query ;
 exec sql declare ZTein cursor for ZTein_ ;
 exec sql open ZTein;
 SQLerror::test(__FILELINE__);
 while(true)
  {
    exec sql fetch ZTein into :db_typ,:db_standard;
    SQLerror::test(__FILELINE__,100);
    if (sqlca.sqlcode) break;
    map_typ[db_typ]=db_standard;
  } 
}
*/
int Zauber::Kosten(const vector<H_Data_typen>& Typ,const Ausnahmen& ausnahmen) const
{
  double fac = ausnahmen.Ausnahmen_float(Name()); 
  if (fac!=0) return (int)(fac*GrundKosten());

  if      (midgard_CG::standard_one_G(Standard(Typ,ausnahmen)) ) fac = 0.5;
  else if (midgard_CG::standard_all_S(Standard(Typ,ausnahmen)) ) fac = 1.0;
  else fac = 5.0; 

  return (int)(fac*GrundKosten());
}

int Zauber::Kosten_eBe(const std::string& pe,const std::string& se) const
{
  double fac; 
    if      (P_Element() == pe ) fac = 0.5;
    else if (S_Element() == se ) fac = 1.0;
    else fac = 5.0;  // oder vielleicht null?

  return (int)(fac*GrundKosten());
}

int Zauber::Erfolgswert(const vector<H_Data_typen>& Typ,const Grundwerte& Werte,const Ausnahmen& ausnahmen) const
{
   assert(Typ.size()==2);
   int ifac=-2;
   vector<std::string> standard=Standard(Typ,ausnahmen);
   if (standard[0]=="G" || standard[1]=="G") ifac=0;

   int ispez=0;
   if (Typ[0]->Short()=="Ma" || Typ[1]->Short()=="Ma") 
      ispez = get_spezial_zauber_for_magier(Werte);

//cout << Name()<<' '<<Werte.Zaubern_wert()<<'+'<<Werte.bo_Za()<<'+'<<ifac<<'+'<<ispez<<'=';
   int erf = Werte.Zaubern_wert()+Werte.bo_Za() + ifac + ispez ;
//cout << erf<<'\n';
   return erf;
}

int Zauber::get_spezial_zauber_for_magier(const Grundwerte& Werte) const
{
 exec sql begin declare section;
   char db_ergebnis[20];
   char db_agens[20];   
   char db_prozess[20]; 
   char db_zauber[100];
 exec sql end declare section;
 strncpy(db_zauber,Name().c_str(),sizeof(db_zauber));
 exec sql select ma,agens,prozess 
   into :db_ergebnis, :db_agens, :db_prozess
   from arkanum_zauber where name = :db_zauber;
 SQLerror::test(__FILELINE__);

 int ispez=0;
 std::string ergebnis = db_ergebnis;
 std::string agens=db_agens;
 std::string prozess=db_prozess;

 if (ergebnis!="G" && agens==Werte.Spezial()) ispez = 2;
 if (ergebnis!="G" && prozess==Werte.Spezial()) ispez = 2;
 return ispez;
}

vector<std::string> Zauber::Standard(const vector<H_Data_typen>& Typ,const Ausnahmen& ausnahmen) const
{
 assert(Typ.size()==2);
 vector<std::string> s(2);
 for(map<std::string,std::string>::const_iterator i=map_typ.begin();i!=map_typ.end();++i)
   if(Typ[0]->Short()==i->first) {s[0]=i->second; break;}
 for(map<std::string,std::string>::const_iterator i=map_typ.begin();i!=map_typ.end();++i)
   if(Typ[1]->Short()==i->first) {s[1]=i->second; break;}
 ausnahmen.Ausnahmen_string(Name(),s);
 return s;
}

std::string Zauber::Standard__(const vector<H_Data_typen>& Typ,const Ausnahmen& a) const
{
 vector<std::string> s = Standard(Typ,a);
 std::string s2=s[0];
 if(Typ[0]->Short()!="" && Typ[1]->Short()!="") s2+="/";
 if(Typ[1]->Short()!="") s2+=s[1];
 return s2;
}

Zauber_All::Zauber_All(Gtk::Label *label)
{
 exec sql begin declare section;
   char db_name[100]; 
 exec sql end declare section;
 exec sql declare ZAein cursor for select distinct name from arkanum_zauber;
 Transaction tr;
 exec sql open ZAein;
 SQLerror::test(__FILELINE__);
 int count=0;
 label->show();
 while(true)
  {
   label->set_text(itos(++count)+" Zauber geladen");
   while(Gtk::Main::events_pending()) Gtk::Main::iteration() ;
   exec sql fetch ZAein into :db_name;
   SQLerror::test(__FILELINE__,100);
   if (sqlca.sqlcode) break;
   list_All.push_back(new Zauber(db_name));
  }
 exec sql close ZAein;
 tr.close();
 label->hide();
}
