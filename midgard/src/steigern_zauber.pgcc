/*  Midgard Character Generator
 *  Copyright (C) 2001 Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include "midgard_CG.hh"
#include <Aux/Transaction.h>
#include <Aux/SQLerror.h>
exec sql include sqlca;
#include <cstring>
#include <Gtk_OStream.h>
#include <strstream>
#include "WindowInfo.hh"

void midgard_CG::on_zauber_laden_clicked()
{   
 if (typ.z=="n") return;
 midgard_CG::on_speichern_clicked();
 midgard_CG::show_alte_zauber();
 midgard_CG::show_neue_zauber();
 midgard_CG::show_alte_zaubermittel();
 midgard_CG::show_neue_zaubermittel();
}


void midgard_CG::show_alte_zauber()
{
   steigern_zauber_clist_alt->clear();
   Gtk::OStream os(steigern_zauber_clist_alt);
   for (vector<st_zauber>::iterator i=zauber.begin(); i!=zauber.end();++i)
      {
         double fac = midgard_CG::get_standard_zauber(typ.s,i->name);
         os << i->name<<"\t"<<i->kosten*fac<<"\n";
      }
   for (unsigned int i=0;i<steigern_zauber_clist_alt->columns().size();++i)
      steigern_zauber_clist_alt->set_column_auto_resize(i,true);
   steigern_zauber_clist_alt->set_reorderable(true);
}


void midgard_CG::show_neue_zauber()
{
  steigern_zauber_clist_neu->clear();
  exec sql begin declare section;
   char db_name[100];
   int db_kosten;
   char db_stufe[10];
   char db_spruchrolle[10];
   char db_standard[20];
   char query[1000];
   char db_region[10];
   char db_zauberart[30];
   char db_p_element[30],db_s_element[30];
  exec sql end declare section;
  string alle_zauber="";
  if (!checkbutton_alle_zauber->get_active() )
      alle_zauber = "("+typ.s+" = 'G' OR "+typ.s+" = 'S' OR "+typ.s+" = 'A') AND ";
//  if (typ.s!="eBe")
    string squery = "SELECT distinct name, kosten, stufe, "+typ.s+", spruchrolle, \
      coalesce(region,''), coalesce(zauberart,''), coalesce(p_element,''), coalesce(s_element,'') \
      FROM arkanum_zauber WHERE "+alle_zauber+"\
      name NOT IN (SELECT fertigkeit FROM charaktere_fertigkeiten \
      WHERE charakter_name = '"+werte.name_charakter+"' \
      AND version = '"+werte.version+"') ORDER BY stufe,name ";


   strncpy(query,squery.c_str(),sizeof(query));
   Transaction tr;
   exec sql prepare zauber_ein_ from :query ;
   exec sql declare zauber_ein cursor for zauber_ein_ ;

   exec sql open zauber_ein;
   SQLerror::test(__FILELINE__);
   Gtk::OStream os(steigern_zauber_clist_neu);
   while (true)
      {
         exec sql fetch zauber_ein into :db_name, :db_kosten, :db_stufe, 
            :db_standard, :db_spruchrolle, :db_region, :db_zauberart,
	    :db_p_element, :db_s_element ;
         SQLerror::test(__FILELINE__,100);  
         if (sqlca.sqlcode) break;
//         double fac= midgard_CG::get_standard_zauber(typ.s,db_name);
         double fac=midgard_CG::get_standard_zauber_(db_standard,db_p_element,db_s_element,db_name);
         if (fac == 0) continue;
         string standard = midgard_CG::Ausnahmen_string(db_name,db_standard);
         string zauberart=db_zauberart;
         if (zauberart=="Zaubersalz" && !checkbutton_zaubersalze->get_active())
            continue;
         if (zauberart=="Beschwörung" && !checkbutton_beschwoerungen->get_active())
            continue;
         if (midgard_CG::region_check(db_region))
          {
            if (!spruchrolle->get_active())
               os << db_stufe <<"\t"<< db_name <<"\t"<<db_kosten*fac<<"\t"<<standard<<"\n";
            else
               if (strcmp(db_spruchrolle,"nicht"))
                  os << db_stufe <<"\t"<< db_name <<"\t"<<db_kosten*fac/10<<"\t"<<standard<<"\n";
          }
      }
   exec sql close zauber_ein;

   for (unsigned int i=0;i<steigern_zauber_clist_neu->columns().size();++i)
      steigern_zauber_clist_neu->set_column_auto_resize(i,true);
   steigern_zauber_clist_neu->set_reorderable(true);
   tr.commit();
}


void midgard_CG::on_steigern_zauber_clist_alt_select_row(gint row, gint column, GdkEvent *event)
{   
   string alt_zauber = steigern_zauber_clist_alt->get_text(row,0);
   int alt_kosten = atoi(steigern_zauber_clist_alt->get_text(row,1).c_str());
   werte.gfp -= alt_kosten;
   for (vector<st_zauber>::iterator i=zauber.begin();
            i!= zauber.end();++i) 
      if (i->name==alt_zauber) {zauber.erase(i);break;}

   midgard_CG::zeige_werte(werte,"alle");
   midgard_CG::show_zauber();
   midgard_CG::on_speichern_clicked();
   midgard_CG::show_alte_zauber();
   midgard_CG::show_neue_zauber();
   midgard_CG::show_alte_zaubermittel();
   midgard_CG::show_neue_zaubermittel();
}

void midgard_CG::on_steigern_zauber_clist_neu_select_row(gint row, gint column, GdkEvent *event)
{   
  int new_kosten = atoi(steigern_zauber_clist_neu->get_text(row,2).c_str());
  string new_zauber = steigern_zauber_clist_neu->get_text(row,1);
  string erf = midgard_CG::get_erfolgswert_zaubern(typ,new_zauber);
  string stufe= steigern_zauber_clist_neu->get_text(row,0);
  string art =steigern_zauber_clist_neu->get_text(row,3);
  
  if (radio_spruchrolle_auto->get_active() && spruchrolle->get_active())
   {
     werte.gfp += 2*new_kosten;
     zauber.push_back(st_zauber("0",new_zauber,erf,"0","0","0","0","0","0","0","0","0","0","0","0","0",0));
   }
  else if (radio_spruchrolle_wuerfeln->get_active() && spruchrolle->get_active())
   {
      int istufe;
      if (stufe != "groß" ) istufe = atoi(stufe.c_str());
      else istufe = 6; // Sprüche der großen Magie werden wie Sprüche der Stufe 6 behandelt 
      int gelungen = midgard_CG::spruchrolle_wuerfeln(istufe,art,new_zauber);
      if (gelungen != 0)
        {
         zauber.push_back(st_zauber("0",new_zauber,erf,"0","0","0","0","0","0","0","0","0","0","0","0","0",0));
         werte.gfp += new_kosten;
        }
      werte.gfp += new_kosten;
   }
  else // normales lernen ohne Spruchrolle
   {
     werte.gfp += new_kosten;
     zauber.push_back(st_zauber("0",new_zauber,erf,"0","0","0","0","0","0","0","0","0","0","0","0","0",0));
   }

  midgard_CG::show_zauber();
  midgard_CG::on_speichern_clicked();
  midgard_CG::zeige_werte(werte,"alle");
  midgard_CG::show_alte_zauber();
  midgard_CG::show_neue_zauber();
   midgard_CG::show_alte_zaubermittel();
   midgard_CG::show_neue_zaubermittel();
}


void midgard_CG::on_checkbutton_zaubersalze_toggled()
{

}
void midgard_CG::on_checkbutton_beschwoerungen_toggled()
{

}
void midgard_CG::on_checkbutton_alle_zauber_toggled()
{

}

void midgard_CG::on_spruchrolle_toggled()
{
 midgard_CG::show_alte_zauber();
 midgard_CG::show_neue_zauber();
}

int midgard_CG::spruchrolle_wuerfeln(int istufe, string art, string zauber)
{
 Random random;
 int erf_z = atoi(werte.zaubern_wert.c_str()) + werte.bo_za ;
 int xr=random.integer(1,20);
 int iaus=0;
 
 if (typ.s != "Ma")
   {
      if (art=="A")  iaus=-2;
   }
 if (typ.s == "Ma") 
   {
    iaus = midgard_CG::get_spezial_zauber(typ.s,zauber);
    if (!iaus)
     {
       if (art=="S")  iaus=+1;
       if (art=="A")  iaus=-1;
     }
   }


 
 int x = xr-istufe;
 x += iaus;
 x += erf_z;
 strstream strinfo;
 strinfo << "Lernversuch von Spruchrolle:\n"
      << " gewürfelt  Spruchstufe  Ausnahme/Spezial Erfolgswert  Gesamtergebnis\n"
      << "    "<<xr<<"            -"<<istufe<<"               "<<iaus<<"             "<<erf_z<<"       =       "<< x<<"\n"<<char(0);
 manage (new WindowInfo(strinfo.str()));
 strinfo.freeze(0);
 if (x>=20) return(1);
 else return(0);
}

// Zaubermittel

void midgard_CG::on_clist_zaubermittel_alt_select_row(gint row, gint column, GdkEvent *event)
{   
   string alt_zauber = clist_zaubermittel_alt->get_text(row,0);
   int alt_kosten = atoi(clist_zaubermittel_alt->get_text(row,1).c_str());
   werte.gfp -= alt_kosten;
   for (vector<st_zaubermittel>::iterator i=vec_zaubermittel.begin();
            i!= vec_zaubermittel.end();++i) 
      if (i->name==alt_zauber) {vec_zaubermittel.erase(i);break;}

   midgard_CG::zeige_werte(werte,"alle");
   midgard_CG::on_speichern_clicked();
   midgard_CG::show_alte_zaubermittel();
   midgard_CG::show_neue_zaubermittel();
}

void midgard_CG::on_clist_zaubermittel_neu_select_row(gint row, gint column, GdkEvent *event)
{   
  int new_kosten = atoi(clist_zaubermittel_neu->get_text(row,3).c_str());
  string new_zaubermittel = clist_zaubermittel_neu->get_text(row,1);
//  vec_zaubermittel.resize(vec_zaubermittel.size()+1);
//  vec_zaubermittel[vec_zaubermittel.size()-1].name = new_zaubermittel;
  vec_zaubermittel.push_back(st_zaubermittel(new_zaubermittel));
  werte.gfp += new_kosten;  

   get_zaubermittel(vec_zaubermittel);
   midgard_CG::zeige_werte(werte,"alle");
   midgard_CG::on_speichern_clicked();
   midgard_CG::show_alte_zaubermittel();
   midgard_CG::show_neue_zaubermittel();
}

void midgard_CG::show_alte_zaubermittel()
{
   clist_zaubermittel_alt->clear();
   Gtk::OStream os(clist_zaubermittel_alt);
   for (vector<st_zaubermittel>::iterator i=vec_zaubermittel.begin(); 
         i!=vec_zaubermittel.end();++i)
     os << i->name<<"\t"<<i->gfp<<"\n";
   for (unsigned int i=0;i<clist_zaubermittel_alt->columns().size();++i)
      clist_zaubermittel_alt->set_column_auto_resize(i,true);
   clist_zaubermittel_alt->set_reorderable(true);
}

void midgard_CG::show_neue_zaubermittel()
{
 clist_zaubermittel_neu->clear();
 exec sql begin declare section;
   char db_name[50], db_art[50], db_zeitaufwand[30], db_preis[50],
         db_standard[5], db_region[10];
   int db_gfp;
   char db_stufe[10];
   char query[1024];
 exec sql end declare section;
 string alle_zauber="";
 if (!checkbutton_alle_zauber->get_active() )
    alle_zauber = " ("+typ.s+" = 'G' OR "+typ.s+" = 'S' OR "+typ.s+" = 'A') AND ";
 string squery = "select z.name, z.kosten_gfp, z.stufe, coalesce(z.art,''), \
   z.zeitaufwand, z.kosten, coalesce(z."+typ.s+",'A'), coalesce(z.region,'') from zauberwerk z \
   where "+alle_zauber+" name NOT IN (SELECT fertigkeit FROM charaktere_fertigkeiten \
   WHERE charakter_name = '"+werte.name_charakter+"' \
   AND version = '"+werte.version+"') order by art, stufe, name";

 strncpy(query,squery.c_str(),sizeof(query));

 Transaction tr;
 exec sql prepare zauberm_ein_ from :query ;
 exec sql declare zauberm_ein cursor for zauberm_ein_ ;
 exec sql open zauberm_ein;
 SQLerror::test(__FILELINE__);
 Gtk::OStream os(clist_zaubermittel_neu);
 while (true)
   {
     exec sql fetch zauberm_ein into :db_name, :db_gfp, :db_stufe, 
            :db_art, :db_zeitaufwand, :db_preis, :db_standard, :db_region ;
     SQLerror::test(__FILELINE__,100);  
     if (sqlca.sqlcode) break;
     double fac= midgard_CG::get_standard_zaubermittel(typ.s,db_name);

//     string standard = midgard_CG::Ausnahmen_string(db_name,db_standard);
     string art=db_art ;
     if (  (midgard_CG::zauberwerk_voraussetzung(db_name) 
            || checkbutton_alle_zauber->get_active() )
         && midgard_CG::region_check(db_region))
       {
         if (art=="AZ") art = "Alchimistisches Zaubermittel";
         if (art=="PZ") art = "Pflanzliches Zaubermittel";
         os << db_stufe <<"\t"<< db_name <<"\t"<<art<<"\t"
            << db_gfp*fac<<"\t"<<db_preis<<"\t"<<db_zeitaufwand<<"\n";
       }
   }
 exec sql close zauberm_ein;

 for (unsigned int i=0;i<clist_zaubermittel_neu->columns().size();++i)
      clist_zaubermittel_neu->set_column_auto_resize(i,true);
 clist_zaubermittel_neu->set_reorderable(true);

 tr.commit();
}

void midgard_CG::get_zaubermittel(vector<st_zaubermittel>& vec_zaubermittel)
{
 exec sql begin declare section;
   char db_name[50], db_art[50], db_zeitaufwand[30], db_kosten[50];
   int db_gfp;
   char db_stufe[10];
 exec sql end declare section;
 for (vector<st_zaubermittel>::iterator i=vec_zaubermittel.begin();
      i!=vec_zaubermittel.end();++i)
   {
    double fac= midgard_CG::get_standard_zaubermittel(typ.s,i->name);
    strncpy(db_name,i->name.c_str(),sizeof(db_name));
    exec sql select kosten_gfp, art, stufe, zeitaufwand, kosten
      into :db_gfp, :db_art, :db_stufe, :db_zeitaufwand, :db_kosten
      from zauberwerk where name = :db_name;
    SQLerror::test(__FILELINE__);    
    i->gfp = db_gfp*fac;
    i->art = db_art;
    i->stufe=db_stufe;
    i->zeitaufwand=db_zeitaufwand;
    i->kosten=db_kosten;
   }
}

bool midgard_CG::zauberwerk_voraussetzung(const string& name)
{
 exec sql begin declare section;
   char db_name[50];
   char db_voraus[10][50];
   char db_operator[10][50];
 exec sql end declare section;
 strncpy(db_name,name.c_str(),sizeof(db_name));
 exec sql select voraussetzung, coalesce(verbindung,'') into :db_voraus, :db_operator 
   from zauberwerk_voraussetzung where name = :db_name;
 SQLerror::test(__FILELINE__,100);    
 if (sqlca.sqlcode) return true; // KEINE VORAUSSETZUNG
 int vanz=sqlca.sqlerrd[2];
 
 exec sql begin declare section;
   char query[1024]; 
   int db_erg;
 exec sql end declare section;
 vector<bool> vb;
 for (int i=0;i<vanz;++i)
   {
    snprintf(query,sizeof(query),"select count(fertigkeit)\
      from charaktere_fertigkeiten \
      where charakter_name = '%s' and version = '%s' and fertigkeit = '%s'",
      werte.name_charakter.c_str(),werte.version.c_str(),db_voraus[i]);
    exec sql prepare qein_ from :query ;
    exec sql declare qein cursor for qein_;
    exec sql open qein;
    SQLerror::test(__FILELINE__);
    exec sql fetch qein into :db_erg;
    exec sql close qein;
    SQLerror::test(__FILELINE__);    
    if (db_erg==0) vb.push_back(false);
    else vb.push_back(true);
   }
 bool back ;
 for (int i=0;i<vanz;++i)
   {
     string op = db_operator[i];     
//cout <<name <<"\t"<< db_voraus[i]<<"\t"<<vb[i]<<"\t"<<op<<"\n";
     // EINE VORAUSSETZUNG
     if (op==""    && vb[i]==true ) return true;
     if (op==""    && vb[i]==false) return false;
     // MEHRERE VORAUSSETZUNGEN
     if (op=="or"  && vb[i]==true) return true; // EINE BELIEBIGE
     if (op=="and" && vb[i]==true) back = true; // ALLE NÖTIG
     else { back=false;break;}               
   }
 return back;
}
