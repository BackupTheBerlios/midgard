#include "Zauber.hh"
#include "midgard_CG.hh"
#include <Aux/SQLerror.h>
#include <Aux/Transaction.h>
#include "class_typen.hh"
exec sql include sqlca;

cH_Zauber::cache_t cH_Zauber::cache;

cH_Zauber::cH_Zauber(const std::string& name,int lernpunkte=0)
{
 st_index index(name,lernpunkte);
 cH_Zauber *cached(cache.lookup(index));
 if (cached) *this=*cached;
 else
  {
   *this=cH_Zauber(new Zauber(name,lernpunkte));
   cache.Register(index,*this);
  }
}

void Zauber::get_Zauber()
{
  exec sql begin declare section;
   char db_ursprung[50];
   int db_kosten;
   char db_stufe[10];
   char db_spruchrolle[10];
   char query[1000];
   char db_region[10];
   char db_zauberart[30];
   char db_p_element[30],db_s_element[30];
   char db_ap[10], db_art[20], db_agens[30], db_prozess[30], 
        db_reagens[30], db_zauberdauer[30], db_reichweite[10],
        db_wirkungsziel[30], db_wirkungsbereich[30], db_wirkungsdauer[20], 
        db_material[50], db_thaumagram[10], db_effekt[1024];
  exec sql end declare section;
//   char db_standard[20],db_standard2[20];
//  strncpy(db_standard2,"",sizeof(db_standard2));
  
  std::string squery = "SELECT coalesce(z.ursprung,''), 
      z.kosten, z.stufe, coalesce(z.spruchrolle,''), coalesce(z.region,''), 
      coalesce(z.zauberart,''),coalesce(z.p_element,''), 
      coalesce(z.s_element,''), z.ap, z.art, coalesce(z.agens,''),
      coalesce(z.prozess,''), coalesce(z.reagens,''),z.zauberdauer,
      z.reichweite,z.wirkungsziel,z.wirkungsbereich,
      z.wirkungsdauer,coalesce(z.material),coalesce(z.thaumagram,''),coalesce(z.effekt,'')
      FROM arkanum_zauber z
      WHERE name = '"+name+"'";
   strncpy(query,squery.c_str(),sizeof(query));
   Transaction tr;
   exec sql prepare cl_zauber_ein_ from :query ;
   exec sql declare cl_zauber_ein cursor for cl_zauber_ein_ ;

//cout << query<<'\n';
   exec sql open cl_zauber_ein;
   SQLerror::test(__FILELINE__);
   exec sql fetch cl_zauber_ein into :db_ursprung, :db_kosten,
      :db_stufe,  :db_spruchrolle, :db_region, :db_zauberart,
      :db_p_element, :db_s_element, :db_ap, :db_art, :db_agens,
      :db_prozess, :db_reagens, :db_zauberdauer, :db_reichweite,
      :db_wirkungsziel, :db_wirkungsbereich, :db_wirkungsdauer, 
      :db_material, :db_thaumagram, :db_effekt;
   SQLerror::test(__FILELINE__);

   ursprung=db_ursprung;   
   kosten=db_kosten;
   stufe=db_stufe;
   spruchrolle=db_spruchrolle;
   region=db_region;
   zauberart=db_zauberart;
   p_element=db_p_element;
   s_element=db_s_element;
   ap=db_ap;
   art=db_art;
   stufe=db_stufe;
   zauberdauer=db_zauberdauer;
   reichweite=db_reichweite;
   wirkungsziel=db_wirkungsziel;
   wirkungsbereich=db_wirkungsbereich;
   wirkungsdauer=db_wirkungsdauer;
   ursprung=db_ursprung;
   material=db_material;
   agens=db_agens;
   prozess=db_prozess;
   reagens=db_reagens;
   beschreibung=db_effekt;
   exec sql close cl_zauber_ein;
   tr.close();
}

void Zauber::get_map_typ()
{
 exec sql begin declare section;
   char query[1024], db_typ[10], db_standard[10];
 exec sql end declare section;
 std::string squery ="select typ,standard from zauber_typen where name ='"+Name()+"'";
 strncpy(query,squery.c_str(),sizeof(query));
 Transaction tr;
 exec sql prepare ZTein_ from :query ;
 exec sql declare ZTein cursor for ZTein_ ;
 exec sql open ZTein;
 SQLerror::test(__FILELINE__);
 while(true)
  {
    exec sql fetch ZTein into :db_typ,:db_standard;
    SQLerror::test(__FILELINE__,100);
    if (sqlca.sqlcode) break;
    map_typ[db_typ]=db_standard;
  } 
}


int Zauber::Kosten(const vector<H_Data_typen>& Typ,const Ausnahmen& ausnahmen) const
{
  double fac = ausnahmen.Ausnahmen_float(Name()); 
  if (fac!=0) return (int)(fac*GrundKosten());

  if      (midgard_CG::standard_one_G(Standard(Typ,ausnahmen)) ) fac = 0.5;
  else if (midgard_CG::standard_all_S(Standard(Typ,ausnahmen)) ) fac = 1.0;
  else fac = 5.0; 

  return (int)(fac*GrundKosten());
}

int Zauber::Kosten_eBe(const std::string& pe,const std::string& se) const
{
  double fac; 
    if      (P_Element() == pe ) fac = 0.5;
    else if (S_Element() == se ) fac = 1.0;
    else fac = 5.0;  // oder vielleicht null?

  return (int)(fac*GrundKosten());
}

int Zauber::Erfolgswert(const vector<H_Data_typen>& Typ,const Grundwerte& Werte,const Ausnahmen& ausnahmen) const
{
   assert(Typ.size()==2);
   int ifac=-2;
   vector<std::string> standard=Standard(Typ,ausnahmen);
   if (standard[0]=="G" || standard[1]=="G") ifac=0;

   int ispez=0;
   if (Typ[0]->Short()=="Ma" || Typ[1]->Short()=="Ma") 
      ispez = get_spezial_zauber_for_magier(Werte);

//cout << Name()<<' '<<Werte.Zaubern_wert()<<'+'<<Werte.bo_Za()<<'+'<<ifac<<'+'<<ispez<<'=';
   int erf = Werte.Zaubern_wert()+Werte.bo_Za() + ifac + ispez ;
//cout << erf<<'\n';
   return erf;
}

int Zauber::get_spezial_zauber_for_magier(const Grundwerte& Werte) const
{
 exec sql begin declare section;
   char db_ergebnis[20];
   char db_agens[20];   
   char db_prozess[20]; 
   char db_zauber[100];
 exec sql end declare section;
 strncpy(db_zauber,Name().c_str(),sizeof(db_zauber));
 exec sql select ma,agens,prozess 
   into :db_ergebnis, :db_agens, :db_prozess
   from arkanum_zauber where name = :db_zauber;
 SQLerror::test(__FILELINE__);

 int ispez=0;
 std::string ergebnis = db_ergebnis;
 std::string agens=db_agens;
 std::string prozess=db_prozess;

 if (ergebnis!="G" && agens==Werte.Spezial()) ispez = 2;
 if (ergebnis!="G" && prozess==Werte.Spezial()) ispez = 2;
 return ispez;
}

vector<std::string> Zauber::set_Standard(const vector<H_Data_typen>& Typ,const Ausnahmen& ausnahmen) const
{
 assert(Typ.size()==2);
 vector<std::string> s(2);
 for(map<std::string,std::string>::const_iterator i=map_typ.begin();i!=map_typ.end();++i)
   if(Typ[0]->Short()==i->first) {s[0]=i->second; break;}
 for(map<std::string,std::string>::const_iterator i=map_typ.begin();i!=map_typ.end();++i)
   if(Typ[1]->Short()==i->first) {s[1]=i->second; break;}
 ausnahmen.Ausnahmen_string(Name(),s);
 return s;
}

std::string Zauber::Standard__(const vector<H_Data_typen>& Typ,const Ausnahmen& a) const
{
 vector<std::string> s = set_Standard(Typ,a);
 std::string s2=s[0];
 if(Typ[1]->Short()!="") s2+="/"+s[1];
 return s2;
}

vector<std::string> Zauber::Standard(const vector<H_Data_typen>& Typ,const Ausnahmen& a) const
{
 return set_Standard(Typ,a);
}

//Q
/*
void Zauber::set_Standard(const vector<H_Data_typen>& Typ)
{
  exec sql begin declare section;
   char db_standard[20],db_standard2[20];
   char query[1000];
  exec sql end declare section;
  strncpy(db_standard2,"",sizeof(db_standard2));
  std::string squery = "SELECT ";
  if (Typ[0]->is_mage()) squery += " coalesce("+Typ[0]->Short()+",'') "; 
  if (Typ[0]->is_mage() && (Typ[1]->Short()!="" && Typ[1]->is_mage())) squery += ",";
  if (Typ[1]->Short()!="" && Typ[1]->is_mage()) squery += " coalesce("+Typ[1]->Short()+",'') ";
  squery += " FROM arkanum_zauber WHERE name = '"+Name()+"'";
  strncpy(query,squery.c_str(),sizeof(query));
  Transaction tr;
  exec sql prepare standard_zauber_ein_ from :query ;
  exec sql declare standard_zauber_ein cursor for standard_zauber_ein_ ;
  exec sql open standard_zauber_ein;
  SQLerror::test(__FILELINE__);
  if (Typ[0]->is_mage() && Typ[1]->is_mage()) // beide Zypen Zauberer
    exec sql fetch standard_zauber_ein into :db_standard, :db_standard2;
  else // ein Typ Zauberer
    exec sql fetch standard_zauber_ein into :db_standard;
  SQLerror::test(__FILELINE__);
  standard.clear();
  standard.push_back(db_standard);
  standard.push_back(db_standard2);
  ausnahmen.Ausnahmen_string(Name(),standard);
}
//Q*/

bool Zauber::zauberwerk_voraussetzung(const std::string& name,const Grundwerte& Werte)
{
 exec sql begin declare section;
   char db_name[50];
   char db_voraus[10][50];
   char db_operator[10][50];
 exec sql end declare section;
 strncpy(db_name,name.c_str(),sizeof(db_name));
 exec sql select voraussetzung, coalesce(verbindung,'') into :db_voraus, :db_operator 
   from zauberwerk_voraussetzung where name = :db_name;
 SQLerror::test(__FILELINE__,100);    
 if (sqlca.sqlcode) return true; // KEINE VORAUSSETZUNG
 int vanz=sqlca.sqlerrd[2];
 
 exec sql begin declare section;
   char query[1024]; 
   int db_erg;
 exec sql end declare section;
 std::vector<bool> vb;
 for (int i=0;i<vanz;++i)
   {
    snprintf(query,sizeof(query),"select count(fertigkeit)\
      from charaktere_fertigkeiten \
      where charakter_name = '%s' and version = '%s' and fertigkeit = '%s'",
      (Werte.Name_Charakter()).c_str(),(Werte.Version()).c_str(),db_voraus[i]);
    exec sql prepare qein_ from :query ;
    exec sql declare qein cursor for qein_;
    exec sql open qein;
    SQLerror::test(__FILELINE__);
    exec sql fetch qein into :db_erg;
    exec sql close qein;
    SQLerror::test(__FILELINE__);    
    if (db_erg==0) vb.push_back(false);
    else vb.push_back(true);
   }
 bool back ;
 for (int i=0;i<vanz;++i)
   {
     std::string op = db_operator[i];     
//std::cout <<name <<"\t"<< db_voraus[i]<<"\t"<<vb[i]<<"\t"<<op<<"\n";
     // EINE VORAUSSETZUNG
     if (op==""    && vb[i]==true ) return true;
     if (op==""    && vb[i]==false) return false;
     // MEHRERE VORAUSSETZUNGEN
     if (op=="or"  && vb[i]==true) return true; // EINE BELIEBIGE
     if (op=="and" && vb[i]==true) back = true; // ALLE NÖTIG
     else { back=false;break;}               
   }
 return back;
}


Zauber_All::Zauber_All()
{
 exec sql begin declare section;
   char db_name[100]; 
 exec sql end declare section;
 exec sql declare ZAein cursor for select distinct name from arkanum_zauber;
 Transaction tr;
 exec sql open ZAein;
 SQLerror::test(__FILELINE__);
 while(true)
  {
   exec sql fetch ZAein into :db_name;
   SQLerror::test(__FILELINE__,100);
   if (sqlca.sqlcode) break;
   list_All.push_back(cH_Zauber(db_name));
  }
 exec sql close ZAein;
 tr.close();

}
