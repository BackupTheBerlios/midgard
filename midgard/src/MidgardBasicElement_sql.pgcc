/*  Midgard Character Generator
 *  Copyright (C) 2001-2002 Malte Thoma
 *                2002 Christof Petig
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include "MidgardBasicElement.hh"
#include "Grundwerte.hh"
#include "Ausnahmen.hh"
#include "export_common.h"
#include "xml.h"
#include "Zauberwerk.hh"
#include "Fertigkeiten.hh"
#include "Waffe.hh"
#include "midgard_CG.hh"
#include <Aux/itos.h>

void MidgardBasicElement::get_map_typ()
{  
 const Tag *tag=this->tag;
 
 if(What()==SPRACHE) 
    tag=cH_Fertigkeit("Sprache")->tag;
 else if(What()==SCHRIFT)
    tag=cH_Fertigkeit("Schreiben")->tag;
 else if(What()==KIDO)
    tag=cH_Fertigkeit("KiDo")->tag;
 else assert(tag);

 if (tag)
 {  FOR_EACH_CONST_TAG(i,*tag)
    {  if (i->Type()=="Grund") map_typ[i->getAttr("Typ")]="G";
       else if (i->Type()=="Standard") map_typ[i->getAttr("Typ")]="S";
       else if (i->Type()=="Ausnahme") map_typ[i->getAttr("Typ")]="A";
    }
 }
}
 

void MidgardBasicElement::get_Steigern_Kosten_map()
{
 const Tag *tag=this->tag;
 const Tag *kosten=0;
 std::string steigern_wie=Name();
 
 if(What()==WAFFE) 
 {  assert(tag);
    typedef map<int,const Tag *> map_int_tag_t;
    static map_int_tag_t waffen_schwierigkeit;
    int schwierigkeit=tag->getIntAttr("Schwierigkeit");
    
    map_int_tag_t::const_iterator i=waffen_schwierigkeit.find(schwierigkeit);
    if (i==waffen_schwierigkeit.end())
    {  kosten=find_Tag("Waffen-Steigern","Kosten","Schwierigkeit",itos(schwierigkeit));
       waffen_schwierigkeit[schwierigkeit]=kosten;
    }
    else kosten=i->second;
 }
 else if(What()==SPRACHE) 
 { tag=cH_Fertigkeit("Sprache")->tag; steigern_wie="Sprache"; }
 else if(What()==SCHRIFT) 
 { tag=cH_Fertigkeit("Schreiben")->tag; steigern_wie="Schreiben"; }
 else assert(tag);

 if (!kosten)
 {  // steigern_wie herausfinden
    const Tag *steigern_wie_t=tag->find("steigern_wie");
    if (steigern_wie_t) steigern_wie=steigern_wie_t->getAttr("Fertigkeit");
    
    // Kosten für steigern_wie suchen: 
    // lokaler Cache, cH_Fertigkeit, dann SteigernKosten
    typedef map<std::string,const Tag *> map_string_tag_t;
    static map_string_tag_t steigern_kosten;

    try
    {  if (steigern_wie==Name()) steigern_wie_t=this->tag;
       else
       {  // zuerst in lokalen Cache (schneller)
          map_string_tag_t::const_iterator i=steigern_kosten.find(steigern_wie);
          if (i!=steigern_kosten.end()) kosten=i->second;
          // Fertigkeit suchen, wenn nicht gefunden wirft es NotFound
          else
             steigern_wie_t=cH_Fertigkeit(steigern_wie)->tag;
       }
          
       if (!kosten)
       {  if (steigern_wie_t)
             kosten=steigern_wie_t->find("Kosten");
          else cerr << "!steigern_wie_t: " << Name() << ',' << What() << '\n';
       }
    } 
    catch (const NotFound &e) // keine Fertigkeit
    {  kosten=find_Tag("SteigernKosten","Kosten","Fertigkeit",steigern_wie);
       steigern_kosten[steigern_wie]=kosten;
    }
 }
 if (!kosten) 
 { cerr << "keine Kosten für '" << steigern_wie << "' gefunden\n";
   return;
 }
 for (int i=1;i<=19;++i)
    map_erfolgswert_kosten[i]=kosten->getIntAttr("Wert"+itos(i),0/*??*/);
}

void MidgardBasicElement::saveElementliste(IF_XML(ostream &datei,)
			   const std::list<cH_MidgardBasicElement>& b,
                           const Grundwerte& Werte,
                           const vector<cH_Typen>& Typ,
                           const Ausnahmen& ausnahmen)
{
  if(b.size()==0) return;
  for (std::list<cH_MidgardBasicElement>::const_iterator i=b.begin();i!=b.end();++i)
   {
      // oder <Beruf Wert=12>Arzt</Beruf> ?
      std::string type=(*i)->What_str();
      if (type.find('.')!=string::npos)
         type.replace(type.find('.'),1,"-");
      datei << "    <" << type;
      write_string_attrib(datei, "Bezeichnung", (*i)->Name());
      write_int_attrib(datei, "Wert", (*i)->Erfolgswert());
//      write_string_attrib(datei, "Region", (*i)->Region());
      write_int_attrib(datei, "Praxispunkte", (*i)->Praxispunkte());

      if ((*i)->What()==ZAUBERWERK)
      {  
        write_string_attrib(datei, "Art", cH_Zauberwerk(*i)->Art());
        write_string_attrib(datei, "Stufe", cH_Zauberwerk(*i)->Stufe());
      }
      else if ((*i)->What()==FERTIGKEIT && cH_Fertigkeit(*i)->ZusatzBool(Typ))
         write_string_attrib(datei, "Zusatz", cH_Fertigkeit(*i)->Zusatz());
      datei << "/>\n";
   }
}

  //////////////////////////////////////////////////////////////////////
  //Steigern von Fertigkeiten  
void MidgardBasicElement::EP_steigern(const std::string fert)
{
// const Tag *tag=find_Tag("Fertigkeiten","Fertigkeit","Name",fert);
 const Tag *steigern=0;
 
 if (tag)
    // Fertigkeit gefunden
    steigern=tag->find("EP-Typ");
 else 
    // globale Liste: Ausdauer, Waffen, Zauber
    steigern=find_Tag("verwendbareEP","EP-Typ","Fertigkeit",fert);

 int back=0;
 if (steigern)
 {  if (steigern->getBoolAttr("KEP")) back+=1;
    if (steigern->getBoolAttr("ZEP")) back+=2;
 }
 steigern_mit_EP=back;
}
