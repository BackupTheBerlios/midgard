#include "Zauber.hh"
#include "midgard_CG.hh"
#include <Aux/SQLerror.h>
#include <Aux/Transaction.h>
#include "Typen.hh"
exec sql include sqlca;
#include <xml.h>

cH_Zauber::cache_t cH_Zauber::cache;

cH_Zauber::cH_Zauber(const std::string& name)
{
 cH_Zauber *cached(cache.lookup(name));
 if (cached) *this=*cached;
 else
#ifndef USE_XML 
  {
   *this=cH_Zauber(new Zauber(name));
   cache.Register(name,*this);
  }
#else
  assert(!"Zauber im Cache");
#endif  
}

#ifdef USE_XML
cH_Zauber::cH_Zauber(const Tag *tag)
{*this=cH_Zauber(new Zauber(tag));
 cache.Register(tag->getAttr("Name"),*this);
}
#endif

void Zauber::get_Zauber()
{
#ifndef USE_XML
  exec sql begin declare section;
   char db_ursprung[50];
   int db_kosten;
   char db_stufe[10];
   char query[1000];
   char db_region[10];
   char db_zauberart[30];
   char db_element[30];
   char db_ap[10], db_art[20], db_agens[30], db_prozess[30], 
        db_reagens[30], db_zauberdauer[30], db_reichweite[10],
        db_wirkungsziel[30], db_wirkungsbereich[30], db_wirkungsdauer[20], 
        db_material[50], db_thaumagram[10];
   bool db_spruchrolle;
  exec sql end declare section;
  
  std::string squery = "SELECT coalesce(z.ursprung,''), 
      z.kosten, z.stufe, z.spruchrolle, coalesce(z.region,''), 
      coalesce(z.zauberart,''), 
      coalesce(z.element,''), z.ap, z.art, coalesce(z.agens,''),
      coalesce(z.prozess,''), coalesce(z.reagens,''),z.zauberdauer,
      z.reichweite,z.wirkungsziel,z.wirkungsbereich,
      z.wirkungsdauer,coalesce(z.material),coalesce(z.thaumagram,'')
      FROM zauber z WHERE name = '"+name+"'";
   strncpy(query,squery.c_str(),sizeof(query));
   Transaction tr;
   exec sql prepare cl_zauber_ein_ from :query ;
   exec sql declare cl_zauber_ein cursor for cl_zauber_ein_ ;

//cout << query<<'\n';
   exec sql open cl_zauber_ein;
   SQLerror::test(__FILELINE__);
   exec sql fetch cl_zauber_ein into :db_ursprung, :db_kosten,
      :db_stufe,  :db_spruchrolle, :db_region, :db_zauberart,
      :db_element, :db_ap, :db_art, :db_agens,
      :db_prozess, :db_reagens, :db_zauberdauer, :db_reichweite,
      :db_wirkungsziel, :db_wirkungsbereich, :db_wirkungsdauer, 
      :db_material, :db_thaumagram;
   SQLerror::test(__FILELINE__);

   ursprung=db_ursprung;   
   kosten=db_kosten;
   stufe=db_stufe;
   spruchrolle=db_spruchrolle;
   region=db_region;
   zauberart=db_zauberart;
   element=db_element;
   ap=db_ap;
   art=db_art;
   stufe=db_stufe;
   zauberdauer=db_zauberdauer;
   reichweite=db_reichweite;
   wirkungsziel=db_wirkungsziel;
   wirkungsbereich=db_wirkungsbereich;
   wirkungsdauer=db_wirkungsdauer;
   ursprung=db_ursprung;
   material=db_material;
   agens=db_agens;
   prozess=db_prozess;
   reagens=db_reagens;
//   beschreibung=db_effekt;
   exec sql close cl_zauber_ein;
   tr.close();
#else // USE_XML
 assert(tag);
 ursprung=tag->getAttr("Ursprung");
    kosten=tag->getIntAttr("Lernkosten");
    stufe=tag->getAttr("Grad");
    spruchrolle=tag->getBoolAttr("Spruchrolle");
    region=tag->getAttr("Region");
    zauberart=tag->getAttr("Zauberart");
    element=tag->getAttr("Element");
    ap=tag->getIntAttr("AP");;
    art=tag->getAttr("Typ");
    zauberdauer=tag->getAttr("Zauberdauer");
    reichweite=tag->getAttr("Reichweite");
    wirkungsziel=tag->getAttr("Wirkungsziel");
    wirkungsbereich=tag->getAttr("Wirkungsbereich");
    wirkungsdauer=tag->getAttr("Wirkungsdauer");
    material=tag->getAttr("Material");
    agens=tag->getAttr("Agens");
    prozess=tag->getAttr("Prozess");
    reagens=tag->getAttr("Reagens");
#endif   
}

int Zauber::Kosten_eBe(const std::string& pe,const std::string& se) const
{
  double fac; 
    if      (Element() == pe ) fac = 0.5;
    else if (Element() == se ) fac = 1.0;
    else fac = 5.0;  // oder vielleicht null?

  return (int)(fac*GrundKosten());
}

int Zauber::Erfolgswert_Z(const vector<cH_Typen>& Typ,const Grundwerte& Werte,const Ausnahmen& ausnahmen) const
{
   assert(Typ.size()==2);
   int ifac=-2;
   vector<std::string> standard=Standard(Typ,ausnahmen);
   if (standard[0]=="G" || standard[1]=="G") ifac=0;

   int ispez=0;
   if (Typ[0]->Short()=="Ma")
      ispez = get_spezial_zauber_for_magier(Werte,standard[0]);
   if (Typ[1]->Short()=="Ma") 
      ispez = get_spezial_zauber_for_magier(Werte,standard[1]);

//cout << Name()<<' '<<Werte.Zaubern_wert()<<'+'<<Werte.bo_Za()<<'+'<<ifac<<'+'<<ispez<<'=';
   int erf = Werte.Zaubern_wert()+Werte.bo_Za() + ifac + ispez ;
//cout << erf<<'\n';
   return erf;
}

int Zauber::get_spezial_zauber_for_magier(const Grundwerte& Werte,const std::string& standard) const
{
 int ispez=0;
 if (standard!="G" && Agens()==Werte.Spezialgebiet()->Spezial()) ispez = 2;
 if (standard!="G" && Prozess()==Werte.Spezialgebiet()->Spezial()) ispez = 2;
 return ispez;
}


Zauber_All::Zauber_All(Gtk::ProgressBar *progressbar)
{
#ifndef USE_XML
 exec sql begin declare section;
   char db_name[50][100]; 
   int db_size;
 exec sql end declare section;
 exec sql select count(name) into :db_size from zauber;
 exec sql declare ZAein cursor for select distinct name from zauber;
 Transaction tr;
 exec sql open ZAein;
 SQLerror::test(__FILELINE__);
 double count=0;
 while(true)
  {
   exec sql fetch 50 in ZAein into :db_name;
   SQLerror::test(__FILELINE__,100);
//   if (sqlca.sqlcode) break;
   int j=sqlca.sqlerrd[2];
   for (int i=0;i<j;++i)
    {
      progressbar->set_percentage(count/db_size);
      while(Gtk::Main::events_pending()) Gtk::Main::iteration() ;
      list_All.push_back(&*(cH_Zauber(db_name[i])));
      ++count;
     }
   if(j<50) break;
  }
 exec sql close ZAein;
 tr.close();
#else // USE_XML
 const Tag *zauber=xml_data->find("Zauber");
 int count=0;
 if (!zauber)
    cerr << "<Zauber><Spruch/>... nicht gefunden\n";
 else
 {  Tag::const_iterator b=zauber->begin(),e=zauber->end();
    double size=e-b;
    FOR_EACH_CONST_TAG_OF_5(i,*zauber,b,e,"Spruch")
    {  if (!((++count)&31))
       {  progressbar->set_percentage((i-b)/size);
          while(Gtk::Main::events_pending()) Gtk::Main::iteration() ;
       }
// warum sowas?
//    die Klasse cH_Zauber enthält den Cache, erzeuge ich nur einen Zauber, so
//    wird er nicht in den Cache (nach Namen) aufgenommen.
//    Ich brauche aber einen cH_MidgardBasicElement, daher bilde ich einen
//    Zauber* um danach (aus dem ebenfalls MidgardBasicElement*) ein 
//    cH_MidgardBasicElement zu machen. Wow.
       list_All.push_back(&*(cH_Zauber(&*i)));
    }
 }
#endif 
 progressbar->set_percentage(1);
}

/*
void Zauber::set_Spruchrolle(std::list<cH_MidgardBasicElement>& L,bool sp) const
{
 for(std::list<cH_MidgardBasicElement>::const_iterator i=L.begin();i!=L.end();++i)
  {
   (*i)->set_Spruchrolle(sp);
  }
}
*/
