/*  Midgard Character Generator
 *  Copyright (C) 2001 Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include "midgard_CG.hh"
#include <Aux/Transaction.h>
#include <Aux/SQLerror.h>
exec sql include sqlca;
#include <cstring>
#include "WindowInfo.hh"

void midgard_CG::on_zauber_laden_clicked()
{   
 if (Typ.Zaubern()=="n" && Typ2.Zaubern()=="n") return;
 midgard_CG::zeige_werte(werte,"alle");
 midgard_CG::on_speichern_clicked();
 midgard_CG::show_alte_zauber();
 midgard_CG::show_neue_zauber();
 midgard_CG::show_alte_zaubermittel();
 midgard_CG::show_neue_zaubermittel();
}

void midgard_CG::on_leaf_selected_alte_zauber(cH_RowDataBase d)
{  const Data_zauber *dt=dynamic_cast<const Data_zauber*>(&*d);
   on_steigern_zauber_tree_alt_select(dt->Name(),dt->Kosten());
}


void midgard_CG::show_alte_zauber()
{
   vector<cH_RowDataBase> datavec;
   for (vector<H_Data_zauber>::const_iterator i=vec_Zauber.begin(); i!=vec_Zauber.end();++i)
      {
         double fac = midgard_CG::get_standard_zauber(Typ,Typ,(*i)->Name());
         datavec.push_back(new Data_zauber((*i)->Name(),(*i)->Ursprung(),(*i)->Kosten()*fac));
      }
   alte_zauber_tree->setDataVec(datavec);
}

void midgard_CG::on_leaf_selected_neue_zauber(cH_RowDataBase d)
{  const Data_zauber *dt=dynamic_cast<const Data_zauber*>(&*d);
   on_steigern_zauber_tree_neu_select(dt->Name(),dt->Kosten(),dt->Stufe(),dt->Art());
}

void midgard_CG::show_neue_zauber()
{
  vector<cH_RowDataBase> datavec;
  exec sql begin declare section;
   char db_name[100],db_ursprung[50];
   int db_kosten;
   char db_stufe[10];
   char db_spruchrolle[10];
   char db_standard[20],db_standard2[20];
   char query[1000];
   char db_region[10];
   char db_zauberart[30];
   char db_p_element[30],db_s_element[30];
  exec sql end declare section;
  strncpy(db_standard2,"",sizeof(db_standard2));
  string alle_zauber="";
  if (!checkbutton_alle_zauber->get_active() )
    {
      if (get_typ_s("Magie",Typ)) alle_zauber += "("+Typ.Short()+" = 'G' OR "+Typ.Short()+" = 'S' OR "+Typ.Short()+" = 'A') ";
      if (get_typ_s("Magie",Typ) && get_typ_s("Magie",Typ2)) alle_zauber += " OR ";
      if (get_typ_s("Magie",Typ) && !get_typ_s("Magie",Typ2)) alle_zauber += " AND ";
      if (get_typ_s("Magie",Typ2)) alle_zauber += "("+Typ2.Short()+" = 'G' OR "+Typ2.Short()+" = 'S' OR "+Typ2.Short()+" = 'A') AND ";
    }
  string squery = "SELECT distinct z.name, z.ursprung, z.kosten, z.stufe, ";
  if (get_typ_s("Magie",Typ)) squery+= "coalesce(z."+Typ.Short()+",''), " ;
  if (Typ2.Short()!="" && get_typ_s("Magie",Typ2)) squery += "coalesce(z."+Typ2.Short()+",''), ";
  squery +=" z.spruchrolle, \
      coalesce(z.region,''), coalesce(z.zauberart,''), \
      coalesce(z.p_element,''), coalesce(z.s_element,'') \
      FROM arkanum_zauber z WHERE "+alle_zauber+"\
      z.name NOT IN (SELECT fertigkeit FROM charaktere_fertigkeiten \
      WHERE charakter_name = '"+werte.name_charakter+"' \
      AND version = '"+werte.version+"') \
      ORDER BY z.stufe,z.name ";


   strncpy(query,squery.c_str(),sizeof(query));
   Transaction tr;
   exec sql prepare zauber_ein_ from :query ;
   exec sql declare zauber_ein cursor for zauber_ein_ ;

   exec sql open zauber_ein;
   SQLerror::test(__FILELINE__);
   while (true)
      {
       if (get_typ_s("Magie",Typ) && get_typ_s("Magie",Typ2)) // beide Zypen Zauberer
         exec sql fetch zauber_ein into :db_name, :db_ursprung, :db_kosten, :db_stufe, 
            :db_standard, :db_standard2, :db_spruchrolle, :db_region, :db_zauberart,
      	    :db_p_element, :db_s_element ;
       else // ein Typ Zauberer
         exec sql fetch zauber_ein into :db_name, :db_ursprung, :db_kosten, :db_stufe, 
            :db_standard, :db_spruchrolle, :db_region, :db_zauberart,
      	    :db_p_element, :db_s_element ;
         SQLerror::test(__FILELINE__,100);  
         if (sqlca.sqlcode) break;
         double fac=midgard_CG::get_standard_zauber_(db_standard,db_standard2,db_p_element,db_s_element,db_name);
         if (fac == 0) continue;
         string standard = midgard_CG::Ausnahmen_string(db_name,db_standard,db_standard2);
         string zauberart=db_zauberart;
         if (zauberart=="Zaubersalz" && !checkbutton_zaubersalze->get_active())
            continue;
         if (zauberart=="Beschwörung" && !checkbutton_beschwoerungen->get_active())
            continue;
         if (midgard_CG::region_check(db_region))
          {
            if (!spruchrolle->get_active())
               datavec.push_back(new Data_zauber(db_stufe,db_name,db_ursprung,db_kosten*fac,standard));
            else if (strcmp(db_spruchrolle,"nicht"))
                 datavec.push_back(new Data_zauber(db_stufe,db_name,db_ursprung,db_kosten*fac/10,standard));
          }
      }
   exec sql close zauber_ein;
   neue_zauber_tree->setDataVec(datavec);

   tr.commit();
}


void midgard_CG::on_steigern_zauber_tree_alt_select(const string& new_zauber, int kosten)
{   
   werte.gfp -= kosten;
   for (vector<H_Data_zauber>::iterator i=vec_Zauber.begin();
            i!= vec_Zauber.end();++i) 
      if ((*i)->Name()==new_zauber) {vec_Zauber.erase(i);break;}
    on_zauber_laden_clicked();
}

void midgard_CG::on_steigern_zauber_tree_neu_select(const string& new_zauber, int kosten, 
   const string& stufe, const string& art)
{   
  int erf = midgard_CG::get_erfolgswert_zaubern(Typ,Typ2,new_zauber);
  
  if (radio_spruchrolle_auto->get_active() && spruchrolle->get_active())
   {
     werte.gfp += 2*kosten;
     vec_Zauber.push_back(new Data_zauber(new_zauber,erf));
   }
  else if (radio_spruchrolle_wuerfeln->get_active() && spruchrolle->get_active())
   {
      int istufe;
      if (stufe != "groß" ) istufe = atoi(stufe.c_str());
      else istufe = 6; // Sprüche der großen Magie werden wie Sprüche der Stufe 6 behandelt 
      int gelungen = midgard_CG::spruchrolle_wuerfeln(istufe,art,new_zauber);
      if (gelungen != 0)
        {
         vec_Zauber.push_back(new Data_zauber(new_zauber,erf));
         werte.gfp += kosten;
        }
      werte.gfp += kosten;
   }
  else // normales lernen ohne Spruchrolle
   {
     werte.gfp += kosten;
     vec_Zauber.push_back(new Data_zauber(new_zauber,erf));
   }
   Zauber_get_Daten(vec_Zauber);
   on_zauber_laden_clicked();
}

void midgard_CG::on_checkbutton_zaubersalze_toggled()
{
 show_neue_zauber();
}
void midgard_CG::on_checkbutton_beschwoerungen_toggled()
{
 show_neue_zauber();
}
void midgard_CG::on_checkbutton_alle_zauber_toggled()
{
 show_neue_zauber();
 show_neue_zaubermittel();
}
void midgard_CG::on_checkbutton_zaubermittel_toggled()
{
 midgard_CG::zeige_werte(werte,"alle");
 midgard_CG::on_speichern_clicked();
 midgard_CG::show_neue_zaubermittel();
 midgard_CG::show_alte_zaubermittel();
}

void midgard_CG::on_spruchrolle_toggled()
{
 midgard_CG::show_alte_zauber();
 midgard_CG::show_neue_zauber();
}

int midgard_CG::spruchrolle_wuerfeln(int istufe, string art, string zauber)
{
 Random random;
 int erf_z = atoi(werte.zaubern_wert.c_str()) + werte.bo_za ;
 int xr=random.integer(1,20);
 int iaus=0;
 
 if (Typ.Short() != "Ma" && Typ2.Short() != "Ma")
   {
      if (art=="A")  iaus=-2;
   }
 else if (Typ.Short() == "Ma" || Typ2.Short() == "Ma" ) 
   {
    if (Typ.Short()=="Ma") iaus = midgard_CG::get_spezial_zauber(Typ.Short(),zauber);
    if (Typ2.Short()=="Ma") iaus = midgard_CG::get_spezial_zauber(Typ2.Short(),zauber);
    if (!iaus)
     {
       if (art=="S")  iaus=+1;
       if (art=="A")  iaus=-1;
     }
   }
 else abort();

 
 int x = xr-istufe;
 x += iaus;
 x += erf_z;
 string strinfo = "Lernversuch von Spruchrolle:
 gewürfelt  Spruchstufe  Ausnahme/Spezial Erfolgswert  Gesamtergebnis\n     "
      +itos(xr)+"            -"+itos(istufe)+"               "
      +itos(iaus)+"             "+itos(erf_z)+"       =       "+ itos(x)+"\n";
 manage (new WindowInfo(strinfo.c_str(),true));
 if (x>=20) return(1);
 else return(0);
}

// Zaubermittel


void midgard_CG::on_leaf_selected_alte_zaubermittel(cH_RowDataBase d)
{  const Data_zaubermittel *dt=dynamic_cast<const Data_zaubermittel*>(&*d);
   on_steigern_zaubermittel_tree_alt_select(dt->Name(),dt->Kosten());
}

void midgard_CG::on_leaf_selected_neue_zaubermittel(cH_RowDataBase d)
{  const Data_zaubermittel *dt=dynamic_cast<const Data_zaubermittel*>(&*d);
   on_steigern_zaubermittel_tree_neu_select(dt->Name(),dt->Stufe(),dt->Kosten());
}


void midgard_CG::on_steigern_zaubermittel_tree_alt_select(const string& name, int kosten)
{   
   werte.gfp -= kosten;
   for (vector<H_Data_zaubermittel>::iterator i=vec_Zaubermittel.begin();
            i!= vec_Zaubermittel.end();++i) 
      if ((*i)->Name()==name) {vec_Zaubermittel.erase(i);break;}

   on_checkbutton_zaubermittel_toggled();
}

void midgard_CG::on_steigern_zaubermittel_tree_neu_select(const string& name, const string& stufe, int kosten)
{   
  vec_Zaubermittel.push_back(new Data_zaubermittel(stufe,name));
  werte.gfp += kosten;  

   get_Zaubermittel(vec_Zaubermittel);
   on_checkbutton_zaubermittel_toggled();
}

void midgard_CG::show_alte_zaubermittel()
{
   vector<cH_RowDataBase> datavec;
   if (!checkbutton_zaubermittel->get_active()) return ;
   for (vector<H_Data_zaubermittel>::iterator i=vec_Zaubermittel.begin(); 
         i!=vec_Zaubermittel.end();++i)
   datavec.push_back(new Data_zaubermittel((*i)->Stufe(),(*i)->Name(),(*i)->Art(),(*i)->Kosten()));
   alte_zaubermittel_tree->setDataVec(datavec);
}


void midgard_CG::show_neue_zaubermittel()
{
 if (!checkbutton_zaubermittel->get_active()) return ;
 vector<cH_RowDataBase> datavec;
 exec sql begin declare section;
   char db_name[50], db_art[50], db_zeitaufwand[30], db_preis[50],
         db_standard[5],db_standard2[5], db_region[10];
   int db_gfp;
   char db_stufe[10];
   char query[1024];
 exec sql end declare section;
 string alle_zauber="";
 if (!checkbutton_alle_zauber->get_active() )
   {
    if (get_typ_s("Magie",Typ)) alle_zauber += " ("+Typ.Short()+" = 'G' OR "+Typ.Short()+" = 'S' OR "+Typ.Short()+" = 'A') AND ";
    if (get_typ_s("Magie",Typ2)) alle_zauber += " ("+Typ2.Short()+" = 'G' OR "+Typ2.Short()+" = 'S' OR "+Typ2.Short()+" = 'A') AND ";
   }

 string squery = "select z.name, z.kosten_gfp, z.stufe, coalesce(z.art,''),
   z.zeitaufwand, z.kosten, ";
 if (get_typ_s("Magie",Typ)) squery += " coalesce(z."+Typ.Short()+",'A'), " ;
 if (get_typ_s("Magie",Typ2)) squery += " coalesce(z."+Typ2.Short()+",'A'), " ;
 squery += " coalesce(z.region,'') from zauberwerk z \
   where "+alle_zauber+" name NOT IN (SELECT fertigkeit FROM charaktere_fertigkeiten \
   WHERE charakter_name = '"+werte.name_charakter+"' \
   AND version = '"+werte.version+"')  order by art, stufe, name";

//   where "+alle_zauber+" (name,stufe) NOT IN (SELECT fertigkeit,wert FROM charaktere_fertigkeiten \


 strncpy(query,squery.c_str(),sizeof(query));
cout << query<<"\n";
 Transaction tr;
 exec sql prepare zauberm_ein_ from :query ;
 exec sql declare zauberm_ein cursor for zauberm_ein_ ;
 exec sql open zauberm_ein;
 SQLerror::test(__FILELINE__);
 while (true)
   {

     if (get_typ_s("Magie",Typ) && get_typ_s("Magie",Typ2)) 
        exec sql fetch zauberm_ein into :db_name, :db_gfp, :db_stufe, 
            :db_art, :db_zeitaufwand, :db_preis, :db_standard, :db_standard2,
            :db_region ;
     else exec sql fetch zauberm_ein into :db_name, :db_gfp, :db_stufe, 
            :db_art, :db_zeitaufwand, :db_preis, :db_standard, :db_region ;
     SQLerror::test(__FILELINE__,100);  
     if (sqlca.sqlcode) break;
     double fac= midgard_CG::get_standard_zaubermittel(Typ,Typ2,db_name);

     string art=db_art ;
     if (  (midgard_CG::zauberwerk_voraussetzung(db_name) 
            || checkbutton_alle_zauber->get_active() )
         && midgard_CG::region_check(db_region))
       {
         if (art=="AZ") art = "Alchimistisches Zaubermittel";
         if (art=="PZ") art = "Pflanzliches Zaubermittel";
         datavec.push_back(new Data_zaubermittel(db_stufe,db_name,art,db_gfp*fac,db_preis,db_zeitaufwand));
       }
   }
 exec sql close zauberm_ein;
 tr.commit();
 neue_zaubermittel_tree->setDataVec(datavec);
}


void midgard_CG::get_Zaubermittel(vector<H_Data_zaubermittel>& vec_Zaubermittel)
{
 exec sql begin declare section;
   char db_name[50], db_art[50], db_zeitaufwand[30], db_kosten[50];
   int db_gfp;
   char db_stufe[10];
 exec sql end declare section;
 for (vector<H_Data_zaubermittel>::iterator i=vec_Zaubermittel.begin();
      i!=vec_Zaubermittel.end();++i)
   {
    double fac= midgard_CG::get_standard_zaubermittel(Typ,Typ2,(*i)->Name());
    strncpy(db_name,((*i)->Name()).c_str(),sizeof(db_name));
    strncpy(db_stufe,((*i)->Stufe()).c_str(),sizeof(db_name));
    exec sql select kosten_gfp, art, zeitaufwand, kosten
      into :db_gfp, :db_art, :db_zeitaufwand, :db_kosten
      from zauberwerk where name = :db_name and stufe = :db_stufe;
    SQLerror::test(__FILELINE__);    
    (*i)->set_Kosten(db_gfp*fac);
    (*i)->set_Art(db_art);
//    (*i)->set_Stufe(db_stufe);
    (*i)->set_Zeitaufwand(db_zeitaufwand);
    (*i)->set_Preis(db_kosten);
   }
}

bool midgard_CG::zauberwerk_voraussetzung(const string& name)
{
 exec sql begin declare section;
   char db_name[50];
   char db_voraus[10][50];
   char db_operator[10][50];
 exec sql end declare section;
 strncpy(db_name,name.c_str(),sizeof(db_name));
 exec sql select voraussetzung, coalesce(verbindung,'') into :db_voraus, :db_operator 
   from zauberwerk_voraussetzung where name = :db_name;
 SQLerror::test(__FILELINE__,100);    
 if (sqlca.sqlcode) return true; // KEINE VORAUSSETZUNG
 int vanz=sqlca.sqlerrd[2];
 
 exec sql begin declare section;
   char query[1024]; 
   int db_erg;
 exec sql end declare section;
 vector<bool> vb;
 for (int i=0;i<vanz;++i)
   {
    snprintf(query,sizeof(query),"select count(fertigkeit)\
      from charaktere_fertigkeiten \
      where charakter_name = '%s' and version = '%s' and fertigkeit = '%s'",
      werte.name_charakter.c_str(),werte.version.c_str(),db_voraus[i]);
    exec sql prepare qein_ from :query ;
    exec sql declare qein cursor for qein_;
    exec sql open qein;
    SQLerror::test(__FILELINE__);
    exec sql fetch qein into :db_erg;
    exec sql close qein;
    SQLerror::test(__FILELINE__);    
    if (db_erg==0) vb.push_back(false);
    else vb.push_back(true);
   }
 bool back ;
 for (int i=0;i<vanz;++i)
   {
     string op = db_operator[i];     
//cout <<name <<"\t"<< db_voraus[i]<<"\t"<<vb[i]<<"\t"<<op<<"\n";
     // EINE VORAUSSETZUNG
     if (op==""    && vb[i]==true ) return true;
     if (op==""    && vb[i]==false) return false;
     // MEHRERE VORAUSSETZUNGEN
     if (op=="or"  && vb[i]==true) return true; // EINE BELIEBIGE
     if (op=="and" && vb[i]==true) back = true; // ALLE NÖTIG
     else { back=false;break;}               
   }
 return back;
}
