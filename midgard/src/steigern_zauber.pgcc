/*  Midgard Character Generator
 *  Copyright (C) 2001 Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include "midgard_CG.hh"
#include <Aux/Transaction.h>
#include <Aux/SQLerror.h>
exec sql include sqlca;
#include <cstring>
#include "WindowInfo.hh"
#include <Aux/EntryValueIntString.h>
#include <Aux/EntryValueEmptyInt.h> 


void midgard_CG::on_zauber_laden_clicked()
{   
 if (typ.z=="n" && typ_2.z=="n") return;
 midgard_CG::zeige_werte(werte,"alle");
 midgard_CG::on_speichern_clicked();
 midgard_CG::show_alte_zauber();
 midgard_CG::show_neue_zauber();
 midgard_CG::show_alte_zaubermittel();
 midgard_CG::show_neue_zaubermittel();
}


class Data_alt_zauber : public RowDataBase
{
   string name, ursprung;
   int kosten;
 public:
   Data_alt_zauber(const string& n, const string& u, int k)
   :name(n),ursprung(u),kosten(k) {}

   virtual const cH_EntryValue Value(int seqnr) const
 { switch (seqnr) {
      case 0 : return cH_EntryValueIntString(name);
      case 1 : return cH_EntryValueIntString(ursprung); 
      case 2 : return cH_EntryValueEmptyInt(kosten);
   }
   return cH_EntryValueIntString("?");
 }
 string Name() const {  return name; }
// string Ursprung() const {  return ursprung; }  
 int Kosten() const {  return kosten; }
};

void midgard_CG::on_leaf_selected_alte_zauber(cH_RowDataBase d)
{  const Data_alt_zauber *dt=dynamic_cast<const Data_alt_zauber*>(&*d);
   on_steigern_zauber_tree_alt_select(dt->Name(),dt->Kosten());
}


void midgard_CG::show_alte_zauber()
{
   vector<cH_RowDataBase> datavec;
   for (vector<st_zauber>::iterator i=zauber.begin(); i!=zauber.end();++i)
      {
         double fac = midgard_CG::get_standard_zauber(typ,typ_2,i->name);
         datavec.push_back(new Data_alt_zauber(i->name,i->ursprung,i->kosten*fac));
      }
   alte_zauber_tree->setDataVec(datavec);
}


class Data_neu_zauber : public RowDataBase
{
   string stufe, name, ursprung;
   int kosten;
   string art;
 public:
   Data_neu_zauber(const string& s,const string& n, const string& u, int k,const string& a)
   :stufe(s),name(n),ursprung(u),kosten(k),art(a) {}

   virtual const cH_EntryValue Value(int seqnr) const
 { switch (seqnr) {
      case 0 : return cH_EntryValueIntString(stufe);
      case 1 : return cH_EntryValueIntString(name); 
      case 2 : return cH_EntryValueIntString(ursprung); 
      case 3 : return cH_EntryValueEmptyInt(kosten);
      case 4 : return cH_EntryValueIntString(art); 
   }
   return cH_EntryValueIntString("?");
 }
 string Name() const {  return name; }
 int Kosten() const {  return kosten; }
 string Stufe() const {  return stufe; }  
 string Art() const {  return art; }  

};

void midgard_CG::on_leaf_selected_neue_zauber(cH_RowDataBase d)
{  const Data_neu_zauber *dt=dynamic_cast<const Data_neu_zauber*>(&*d);
   on_steigern_zauber_tree_neu_select(dt->Name(),dt->Kosten(),dt->Stufe(),dt->Art());
}


void midgard_CG::show_neue_zauber()
{
  vector<cH_RowDataBase> datavec;
  exec sql begin declare section;
   char db_name[100],db_ursprung[50];
   int db_kosten;
   char db_stufe[10];
   char db_spruchrolle[10];
   char db_standard[20],db_standard2[20];
   char query[1000];
   char db_region[10];
   char db_zauberart[30];
   char db_p_element[30],db_s_element[30];
  exec sql end declare section;
  strncpy(db_standard2,"",sizeof(db_standard2));
  string alle_zauber="";
  if (!checkbutton_alle_zauber->get_active() )
    {
      if (get_typ_s("Magie",typ)) alle_zauber += "("+typ.s+" = 'G' OR "+typ.s+" = 'S' OR "+typ.s+" = 'A') ";
      if (get_typ_s("Magie",typ) && get_typ_s("Magie",typ_2)) alle_zauber += " OR ";
      if (get_typ_s("Magie",typ) && !get_typ_s("Magie",typ_2)) alle_zauber += " AND ";
      if (get_typ_s("Magie",typ_2)) alle_zauber += "("+typ_2.s+" = 'G' OR "+typ_2.s+" = 'S' OR "+typ_2.s+" = 'A') AND ";
    }
  string squery = "SELECT distinct z.name, z.ursprung, z.kosten, z.stufe, ";
  if (get_typ_s("Magie",typ)) squery+= "coalesce(z."+typ.s+",''), " ;
  if (typ_2.s!="" && get_typ_s("Magie",typ_2)) squery += "coalesce(z."+typ_2.s+",''), ";
  squery +=" z.spruchrolle, \
      coalesce(z.region,''), coalesce(z.zauberart,''), \
      coalesce(z.p_element,''), coalesce(z.s_element,'') \
      FROM arkanum_zauber z WHERE "+alle_zauber+"\
      z.name NOT IN (SELECT fertigkeit FROM charaktere_fertigkeiten \
      WHERE charakter_name = '"+werte.name_charakter+"' \
      AND version = '"+werte.version+"') \
      ORDER BY z.stufe,z.name ";


   strncpy(query,squery.c_str(),sizeof(query));
   Transaction tr;
   exec sql prepare zauber_ein_ from :query ;
   exec sql declare zauber_ein cursor for zauber_ein_ ;

   exec sql open zauber_ein;
   SQLerror::test(__FILELINE__);
   while (true)
      {
       if (get_typ_s("Magie",typ) && get_typ_s("Magie",typ_2)) // beide Zypen Zauberer
         exec sql fetch zauber_ein into :db_name, :db_ursprung, :db_kosten, :db_stufe, 
            :db_standard, :db_standard2, :db_spruchrolle, :db_region, :db_zauberart,
      	    :db_p_element, :db_s_element ;
       else // ein Typ Zauberer
         exec sql fetch zauber_ein into :db_name, :db_ursprung, :db_kosten, :db_stufe, 
            :db_standard, :db_spruchrolle, :db_region, :db_zauberart,
      	    :db_p_element, :db_s_element ;
         SQLerror::test(__FILELINE__,100);  
         if (sqlca.sqlcode) break;
         double fac=midgard_CG::get_standard_zauber_(db_standard,db_standard2,db_p_element,db_s_element,db_name);
         if (fac == 0) continue;
         string standard = midgard_CG::Ausnahmen_string(db_name,db_standard,db_standard2);
         string zauberart=db_zauberart;
         if (zauberart=="Zaubersalz" && !checkbutton_zaubersalze->get_active())
            continue;
         if (zauberart=="Beschwörung" && !checkbutton_beschwoerungen->get_active())
            continue;
         if (midgard_CG::region_check(db_region))
          {
            if (!spruchrolle->get_active())
               datavec.push_back(new Data_neu_zauber(db_stufe,db_name,db_ursprung,db_kosten*fac,standard));
            else
               if (strcmp(db_spruchrolle,"nicht"))
                  datavec.push_back(new Data_neu_zauber(db_stufe,db_name,db_ursprung,db_kosten*fac/10,standard));
          }
      }
   exec sql close zauber_ein;
   neue_zauber_tree->setDataVec(datavec);

   tr.commit();
}


void midgard_CG::on_steigern_zauber_tree_alt_select(const string& new_zauber, int kosten)
{   
   werte.gfp -= kosten;
   for (vector<st_zauber>::iterator i=zauber.begin();
            i!= zauber.end();++i) 
      if (i->name==new_zauber) {zauber.erase(i);break;}

  on_zauber_laden_clicked();
}

void midgard_CG::on_steigern_zauber_tree_neu_select(const string& new_zauber, int kosten, 
   const string& stufe, const string& art)
{   
  string erf = midgard_CG::get_erfolgswert_zaubern(typ,typ_2,new_zauber);
  
  if (radio_spruchrolle_auto->get_active() && spruchrolle->get_active())
   {
     werte.gfp += 2*kosten;
     zauber.push_back(st_zauber("0",new_zauber,erf,"0","0","0","0","0","0","0","0","0","0","0","0","0",0));
   }
  else if (radio_spruchrolle_wuerfeln->get_active() && spruchrolle->get_active())
   {
      int istufe;
      if (stufe != "groß" ) istufe = atoi(stufe.c_str());
      else istufe = 6; // Sprüche der großen Magie werden wie Sprüche der Stufe 6 behandelt 
      int gelungen = midgard_CG::spruchrolle_wuerfeln(istufe,art,new_zauber);
      if (gelungen != 0)
        {
         zauber.push_back(st_zauber("0",new_zauber,erf,"0","0","0","0","0","0","0","0","0","0","0","0","0",0));
         werte.gfp += kosten;
        }
      werte.gfp += kosten;
   }
  else // normales lernen ohne Spruchrolle
   {
     werte.gfp += kosten;
     zauber.push_back(st_zauber("0",new_zauber,erf,"0","0","0","0","0","0","0","0","0","0","0","0","0",0));
   }

   on_zauber_laden_clicked();
}

void midgard_CG::on_checkbutton_zaubersalze_toggled()
{
 show_neue_zauber();
}
void midgard_CG::on_checkbutton_beschwoerungen_toggled()
{
 show_neue_zauber();
}
void midgard_CG::on_checkbutton_alle_zauber_toggled()
{
 show_neue_zauber();
 show_neue_zaubermittel();
}
void midgard_CG::on_checkbutton_zaubermittel_toggled()
{
 midgard_CG::zeige_werte(werte,"alle");
 midgard_CG::on_speichern_clicked();
 midgard_CG::show_neue_zaubermittel();
 midgard_CG::show_alte_zaubermittel();
}

void midgard_CG::on_spruchrolle_toggled()
{
 midgard_CG::show_alte_zauber();
 midgard_CG::show_neue_zauber();
}

int midgard_CG::spruchrolle_wuerfeln(int istufe, string art, string zauber)
{
 Random random;
 int erf_z = atoi(werte.zaubern_wert.c_str()) + werte.bo_za ;
 int xr=random.integer(1,20);
 int iaus=0;
 
 if (typ.s != "Ma" && typ_2.s != "Ma")
   {
      if (art=="A")  iaus=-2;
   }
 else if (typ.s == "Ma" || typ_2.s == "Ma" ) 
   {
    if (typ.s=="Ma") iaus = midgard_CG::get_spezial_zauber(typ.s,zauber);
    if (typ_2.s=="Ma") iaus = midgard_CG::get_spezial_zauber(typ_2.s,zauber);
    if (!iaus)
     {
       if (art=="S")  iaus=+1;
       if (art=="A")  iaus=-1;
     }
   }
 else abort();

 
 int x = xr-istufe;
 x += iaus;
 x += erf_z;
 string strinfo = "Lernversuch von Spruchrolle:
 gewürfelt  Spruchstufe  Ausnahme/Spezial Erfolgswert  Gesamtergebnis\n     "
      +itos(xr)+"            -"+itos(istufe)+"               "
      +itos(iaus)+"             "+itos(erf_z)+"       =       "+ itos(x)+"\n";
 manage (new WindowInfo(strinfo.c_str(),true));
 if (x>=20) return(1);
 else return(0);
}

// Zaubermittel


class Data_alt_zaubermittel : public RowDataBase
{
   string name;
   int kosten;
 public:
   Data_alt_zaubermittel(const string& n, int k)
   :name(n),kosten(k) {}

   virtual const cH_EntryValue Value(int seqnr) const
 { switch (seqnr) {
      case 0 : return cH_EntryValueIntString(name);
      case 1 : return cH_EntryValueEmptyInt(kosten);
   }
   return cH_EntryValueIntString("?");
 }
 string Name() const {  return name; }
 int Kosten() const {  return kosten; }
};

void midgard_CG::on_leaf_selected_alte_zaubermittel(cH_RowDataBase d)
{  const Data_alt_zaubermittel *dt=dynamic_cast<const Data_alt_zaubermittel*>(&*d);
   on_steigern_zaubermittel_tree_alt_select(dt->Name(),dt->Kosten());
}

class Data_neu_zaubermittel : public RowDataBase
{
   int stufe;
   string name, art;
   int kosten;
   string preis, zeitaufwand;
 public:
   Data_neu_zaubermittel(int s,const string& n, const string& a,int k,const string& p, const string& z)
   :stufe(s),name(n),art(a),kosten(k),preis(p),zeitaufwand(z) {}

   virtual const cH_EntryValue Value(int seqnr) const
 { switch (seqnr) {
      case 0 : return cH_EntryValueEmptyInt(stufe);
      case 1 : return cH_EntryValueIntString(name);
      case 2 : return cH_EntryValueIntString(art);
      case 3 : return cH_EntryValueEmptyInt(kosten);
      case 4 : return cH_EntryValueIntString(preis);
      case 5 : return cH_EntryValueIntString(zeitaufwand);
   }
   return cH_EntryValueIntString("?");
 }
 string Name() const {  return name; }
 int Kosten() const {  return kosten; }
};

void midgard_CG::on_leaf_selected_neue_zaubermittel(cH_RowDataBase d)
{  const Data_alt_zaubermittel *dt=dynamic_cast<const Data_alt_zaubermittel*>(&*d);
   on_steigern_zaubermittel_tree_neu_select(dt->Name(),dt->Kosten());
}


void midgard_CG::on_steigern_zaubermittel_tree_alt_select(const string& name, int kosten)
{   
   werte.gfp -= kosten;
   for (vector<st_zaubermittel>::iterator i=vec_zaubermittel.begin();
            i!= vec_zaubermittel.end();++i) 
      if (i->name==name) {vec_zaubermittel.erase(i);break;}

   on_checkbutton_zaubermittel_toggled();
}

void midgard_CG::on_steigern_zaubermittel_tree_neu_select(const string& name, int kosten)
{   
  vec_zaubermittel.push_back(st_zaubermittel(name));
  werte.gfp += kosten;  

   get_zaubermittel(vec_zaubermittel);
   on_checkbutton_zaubermittel_toggled();
}

void midgard_CG::show_alte_zaubermittel()
{
   vector<cH_RowDataBase> datavec;
   if (!checkbutton_zaubermittel->get_active()) return ;
   for (vector<st_zaubermittel>::iterator i=vec_zaubermittel.begin(); 
         i!=vec_zaubermittel.end();++i)
   datavec.push_back(new Data_alt_zaubermittel(i->name,i->gfp));
   alte_zaubermittel_tree->setDataVec(datavec);
}


void midgard_CG::show_neue_zaubermittel()
{
 if (!checkbutton_zaubermittel->get_active()) return ;
 vector<cH_RowDataBase> datavec;
 exec sql begin declare section;
   char db_name[50], db_art[50], db_zeitaufwand[30], db_preis[50],
         db_standard[5],db_standard2[5], db_region[10];
   int db_gfp;
   char db_stufe[10];
   char query[1024];
 exec sql end declare section;
 string alle_zauber="";
 if (!checkbutton_alle_zauber->get_active() )
   {
    if (get_typ_s("Magie",typ)) alle_zauber += " ("+typ.s+" = 'G' OR "+typ.s+" = 'S' OR "+typ.s+" = 'A') AND ";
    if (get_typ_s("Magie",typ_2)) alle_zauber += " ("+typ_2.s+" = 'G' OR "+typ_2.s+" = 'S' OR "+typ_2.s+" = 'A') AND ";
   }

 string squery = "select z.name, z.kosten_gfp, z.stufe, coalesce(z.art,''),
   z.zeitaufwand, z.kosten, ";
 if (get_typ_s("Magie",typ)) squery += " coalesce(z."+typ.s+",'A'), " ;
 if (get_typ_s("Magie",typ_2)) squery += " coalesce(z."+typ_2.s+",'A'), " ;
 squery += " coalesce(z.region,'') from zauberwerk z \
   where "+alle_zauber+" name NOT IN (SELECT fertigkeit FROM charaktere_fertigkeiten \
   WHERE charakter_name = '"+werte.name_charakter+"' \
   AND version = '"+werte.version+"') order by art, stufe, name";

 strncpy(query,squery.c_str(),sizeof(query));

 Transaction tr;
 exec sql prepare zauberm_ein_ from :query ;
 exec sql declare zauberm_ein cursor for zauberm_ein_ ;
 exec sql open zauberm_ein;
 SQLerror::test(__FILELINE__);
 while (true)
   {

     if (get_typ_s("Magie",typ) && get_typ_s("Magie",typ_2)) 
        exec sql fetch zauberm_ein into :db_name, :db_gfp, :db_stufe, 
            :db_art, :db_zeitaufwand, :db_preis, :db_standard, :db_standard2,
            :db_region ;
     else exec sql fetch zauberm_ein into :db_name, :db_gfp, :db_stufe, 
            :db_art, :db_zeitaufwand, :db_preis, :db_standard, :db_region ;
     SQLerror::test(__FILELINE__,100);  
     if (sqlca.sqlcode) break;
     double fac= midgard_CG::get_standard_zaubermittel(typ,typ_2,db_name);

     string art=db_art ;
     if (  (midgard_CG::zauberwerk_voraussetzung(db_name) 
            || checkbutton_alle_zauber->get_active() )
         && midgard_CG::region_check(db_region))
       {
         if (art=="AZ") art = "Alchimistisches Zaubermittel";
         if (art=="PZ") art = "Pflanzliches Zaubermittel";
         datavec.push_back(new Data_neu_zaubermittel(atoi(db_stufe),db_name,art,db_gfp*fac,db_preis,db_zeitaufwand));
       }
   }
 exec sql close zauberm_ein;
 tr.commit();
 neue_zaubermittel_tree->setDataVec(datavec);
}


void midgard_CG::get_zaubermittel(vector<st_zaubermittel>& vec_zaubermittel)
{
 exec sql begin declare section;
   char db_name[50], db_art[50], db_zeitaufwand[30], db_kosten[50];
   int db_gfp;
   char db_stufe[10];
 exec sql end declare section;
 for (vector<st_zaubermittel>::iterator i=vec_zaubermittel.begin();
      i!=vec_zaubermittel.end();++i)
   {
    double fac= midgard_CG::get_standard_zaubermittel(typ,typ_2,i->name);
    strncpy(db_name,i->name.c_str(),sizeof(db_name));
    exec sql select kosten_gfp, art, stufe, zeitaufwand, kosten
      into :db_gfp, :db_art, :db_stufe, :db_zeitaufwand, :db_kosten
      from zauberwerk where name = :db_name;
    SQLerror::test(__FILELINE__);    
    i->gfp = db_gfp*fac;
    i->art = db_art;
    i->stufe=db_stufe;
    i->zeitaufwand=db_zeitaufwand;
    i->kosten=db_kosten;
   }
}

bool midgard_CG::zauberwerk_voraussetzung(const string& name)
{
 exec sql begin declare section;
   char db_name[50];
   char db_voraus[10][50];
   char db_operator[10][50];
 exec sql end declare section;
 strncpy(db_name,name.c_str(),sizeof(db_name));
 exec sql select voraussetzung, coalesce(verbindung,'') into :db_voraus, :db_operator 
   from zauberwerk_voraussetzung where name = :db_name;
 SQLerror::test(__FILELINE__,100);    
 if (sqlca.sqlcode) return true; // KEINE VORAUSSETZUNG
 int vanz=sqlca.sqlerrd[2];
 
 exec sql begin declare section;
   char query[1024]; 
   int db_erg;
 exec sql end declare section;
 vector<bool> vb;
 for (int i=0;i<vanz;++i)
   {
    snprintf(query,sizeof(query),"select count(fertigkeit)\
      from charaktere_fertigkeiten \
      where charakter_name = '%s' and version = '%s' and fertigkeit = '%s'",
      werte.name_charakter.c_str(),werte.version.c_str(),db_voraus[i]);
    exec sql prepare qein_ from :query ;
    exec sql declare qein cursor for qein_;
    exec sql open qein;
    SQLerror::test(__FILELINE__);
    exec sql fetch qein into :db_erg;
    exec sql close qein;
    SQLerror::test(__FILELINE__);    
    if (db_erg==0) vb.push_back(false);
    else vb.push_back(true);
   }
 bool back ;
 for (int i=0;i<vanz;++i)
   {
     string op = db_operator[i];     
//cout <<name <<"\t"<< db_voraus[i]<<"\t"<<vb[i]<<"\t"<<op<<"\n";
     // EINE VORAUSSETZUNG
     if (op==""    && vb[i]==true ) return true;
     if (op==""    && vb[i]==false) return false;
     // MEHRERE VORAUSSETZUNGEN
     if (op=="or"  && vb[i]==true) return true; // EINE BELIEBIGE
     if (op=="and" && vb[i]==true) back = true; // ALLE NÖTIG
     else { back=false;break;}               
   }
 return back;
}
