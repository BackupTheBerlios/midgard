// $Id: fertigk_exp.pgcc,v 1.27 2001/12/06 12:13:42 christof Exp $
/*  Midgard Roleplaying Character Generator
 *  Copyright (C) 2001 Christof Petig
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <fstream>
#include <Aux/Transaction.h>
#include <Aux/dbconnect.h>
exec sql include sqlca;
#include "export_common.h"
#include <Aux/itos.h>

// wegen eines bugs in epcg <=V6.1
#define GARNIX 

void fert_speichern(std::ostream &o)
{  
   Transaction t;
   exec sql allocate descriptor spalten;
   
  {Query query("select fertigkeit, region, lp as lernpunkte, anfangswert0,"
  	" fp, anfangswert, attribut"
  	" from fertigkeiten"
  	" order by region,fertigkeit");
   o << " <Fertigkeiten>\n";
   FetchIStream is;
  while ((query>>is).good())
  {o << "  <Fertigkeit";
   string fert=fetch_and_write_string_attrib(is, o, "Name");
   fetch_and_write_string_attrib(is, o, "Region");
   fetch_and_write_int_attrib(is, o, "Lernpunkte");
   fetch_and_write_int_attrib(is, o, "Anfangswert");
   fetch_and_write_int_attrib(is, o, "Lernkosten");
   fetch_and_write_int_attrib(is, o, "Erfolgswert");
   fetch_and_write_string_attrib(is, o, "Attribut");
   o << ">\n";
   
   grund_standard_ausnahme(o, "fertigkeiten_typen", fert);
      //********** fertigkeiten_voraussetzung **********************************
   {  Query query2("select st,gw,gs,ko,\"in\",zt,au,pa,sb,rw, fertigkeit"
   	" from fertigkeiten_voraussetzung"
   	" where name='"+fert+"' order by fertigkeit");
      FetchIStream is2;
      while ((query2>>is2).good()) 
      {  o << "    <Voraussetzungen";
         fetch_and_write_int_attrib(is2, o, "St");
         fetch_and_write_int_attrib(is2, o, "Gw");
         fetch_and_write_int_attrib(is2, o, "Gs");
         fetch_and_write_int_attrib(is2, o, "Ko");
         fetch_and_write_int_attrib(is2, o, "In");
         fetch_and_write_int_attrib(is2, o, "Zt");
         fetch_and_write_int_attrib(is2, o, "Au");
         fetch_and_write_int_attrib(is2, o, "pA");
         fetch_and_write_int_attrib(is2, o, "Sb");
         fetch_and_write_int_attrib(is2, o, "RW");
         fetch_and_write_string_attrib(is2, o, "Fertigkeit");
         o << "/>\n";
      }
    }
   
      //********** Lernschema **********************************
    lernschema(o, "Fertigkeit", fert);
    pflicht_lernen(o, fert);
    verbot_lernen(o, fert);
    ausnahmen(o, "f", fert);

// ************************* Steigern wie *****************************
    {  Query query2("select wie from steigern_fertigkeiten where name='"+fert+"'");
       FetchIStream is2=query2.Fetch();
       if (is2.good())
       {  o << "    <steigern_wie";
          fetch_and_write_string_attrib(is2, o, "Fertigkeit");
          o << "/>\n";
       }
    }
//********************* praxispunkte ********************
      { Query query2("select coalesce(max_wert,0), coalesce(lernfaktor,0)"
      		" from praxispunkte where name='"+fert+"'");
      	FetchIStream is2=query2.Fetch();
      	if (is2.good())
      	{  o << "    <Praxispunkte";
           fetch_and_write_int_attrib(is2, o, "MaximalWert");
           fetch_and_write_int_attrib(is2, o, "Lernfaktor");
           o << "/>\n";
        }
      }

//********************* steigern_fertigkeiten_werte ********************
      {  Query query2("select"
      	    " coalesce(p0,0), coalesce(p1,0), coalesce(p2,0), coalesce(p3,0),"
      	    " coalesce(p4,0), coalesce(p5,0), coalesce(p6,0), coalesce(p7,0),"
      	    " coalesce(p8,0), coalesce(p9,0), coalesce(p10,0), coalesce(p11,0),"
      	    " coalesce(p12,0), coalesce(p13,0), coalesce(p14,0), coalesce(p15,0),"
      	    " coalesce(p16,0), coalesce(p17,0), coalesce(p18,0), coalesce(p19,0),"
      	    " coalesce(p20,0), coalesce(p21,0), coalesce(p22,0), coalesce(p23,0),"
      	    " coalesce(p24,0), coalesce(p25,0), coalesce(p26,0), coalesce(p27,0),"
      	    " coalesce(p28,0)"
       	    " from steigern_fertigkeiten_werte"
       	    " where name='"+fert+"'");;
      	FetchIStream is2=query2.Fetch();
      	if (is2.good())
        {  o << "    <Kosten";
           for (int i=0;i<=28;++i) 
              fetch_and_write_int_attrib(is2, o, "Wert"+itos(i));
           o << "/>\n";
        }
      }

      //********** ZEP oder KEP ? ****************
     {   Query query2("select ep from steigern_fertigkeiten_mit"
     		" where name='"+fert+"' order by ep");
      	FetchIStream is2;
      	std::string ep;
      	while ((query2>>is2).good())
        {  if (!ep.empty()) ep+=',';
           ep+=fetch_string(is2);
        }
        if (!ep.empty())
           o << "    <EP-Typ Typ=\"" << ep << "\"/>\n";
     }
   
   o << "  </Fertigkeit>\n";
  }
   o << " </Fertigkeiten>\n";
  }

//********************* angeborene Fertigkeiten ********************
   o << " <angeboreneFertigkeiten>\n";
  {Query query("select name, min, max, wert"
  	" from angeborene_fertigkeiten"
  	" order by name");
   FetchIStream is;
   while ((query>>is).good())
  {o << "  <angeboreneFertigkeit";
   fetch_and_write_string_attrib(is, o, "Name");
   fetch_and_write_int_attrib(is, o, "Min");
   fetch_and_write_int_attrib(is, o, "Max");
   fetch_and_write_int_attrib(is, o, "Wert");
   o << "/>\n";
  }
   o << " </angeboreneFertigkeiten>\n";
  }

//********************* Berufe ********************
   o << " <Berufe>\n";
#warning hier noch ge durch gs,gw ersetzen
  {Query query("select beruf, region, lernpunkte, st, ge as gw, ge as gs, ko,"
  	" \"in\", zt, pa, au, sb, typ, geschlecht"
   	" from berufe_voraussetzung"
   	" order by region, beruf");
   FetchIStream is;
   while ((query>>is).good())
  {o << "  <Beruf";
   std::string beruf=fetch_and_write_string_attrib(is, o, "Name");
   fetch_and_write_string_attrib(is, o, "Region");
   fetch_and_write_int_attrib(is, o, "Lernpunkte");
   o << ">\n";
   o << "    <Voraussetzungen";
   fetch_and_write_int_attrib(is, o, "St");
   fetch_and_write_int_attrib(is, o, "Gw");
   fetch_and_write_int_attrib(is, o, "Gs");
   fetch_and_write_int_attrib(is, o, "Ko");
   fetch_and_write_int_attrib(is, o, "In");
   fetch_and_write_int_attrib(is, o, "Zt");
   fetch_and_write_int_attrib(is, o, "pA");
   fetch_and_write_int_attrib(is, o, "Au");
   fetch_and_write_int_attrib(is, o, "Sb");
   fetch_and_write_typ_attrib(is, o, "Typ");
   fetch_and_write_string_attrib(is, o, "Geschlecht");
   o << "/>\n";
   {  
      Query query2("select stand from berufe_stand where beruf='"+beruf
      		+"' order by stand");
      FetchIStream is2;
      std::string staende;
      while ((query2>>is2).good())
      {  if (!staende.empty()) staende+=',';
         staende+=fetch_string(is2);
      }
      if (!staende.empty())
         o << "    <Stand>" << staende << "</Stand>\n";
   }
   {  Query query2("select vorteil from berufe_vorteile where beruf='"+beruf
      		+"' order by vorteil");
      FetchIStream is2;
      std::string vorteile;
      while ((query2>>is2).good())
      {  if (!vorteile.empty()) vorteile+=',';
         vorteile+=fetch_string(is2);
      }
      if (!vorteile.empty())
         o << "    <Vorteil>" << vorteile << "</Vorteil>\n";
   }

   pflicht_lernen(o, beruf);
   verbot_lernen(o, beruf);
   o << "  </Beruf>\n";
  }
   o << " </Berufe>\n";
  }

//********************* Pflicht + verboten ********************
   o << " <Typ-Pflichten>\n";
   o << "    <-- hier stehen nur die Dinge, die nicht schon Fertigkeiten/Berufe sind -->\n";
   exec sql declare pflicht_curs cursor for
   	select pflicht, typ, lernpunkte, verboten, spielbegin, erfolgswert
   	from pflicht_lernen
   	where not exists (select true from fertigkeiten 
   		where pflicht=fertigkeit or verboten=fertigkeit)
   	and not exists (select true from berufe_voraussetzung 
   		where pflicht=beruf or verboten=beruf)
   	order by typ,coalesce(pflicht,''),verboten;
   exec sql open pflicht_curs;
   SQLerror::test(__FILELINE__);
  while (true)
  {exec sql fetch pflicht_curs into sql descriptor spalten;
   SQLerror::test(__FILELINE__,100);
   if (sqlca.sqlcode) break;
   FetchIStream is("spalten");
   std::string pflicht=fetch_string(is);
   if (pflicht.size())
   {  o << "  <Pflicht";
      fetch_and_write_string_attrib(is, o, "Typ");
      write_string_attrib(o, "Fertigkeit", pflicht);
      fetch_and_write_int_attrib(is, o, "Lernpunkte");
      fetch_string(is);
      fetch_and_write_string_attrib(is, o, "Spielbeginn");
      fetch_and_write_int_attrib(is, o, "Erfolgswert");
      o << "/>\n";
   }
   else
   {  o << "  <Verbot";
      fetch_and_write_string_attrib(is, o, "Typ");
      fetch_int(is);
      fetch_and_write_string_attrib(is, o, "Fertigkeit");
      fetch_and_write_string_attrib(is, o, "Spielbeginn");
      o << "/>\n";
   }
  }
   exec sql close pflicht_curs;
   SQLerror::test(__FILELINE__);
   o << " </Typ-Pflichten>\n";

//********************* praxispunkte ********************
   o << " <Praxispunkte>\n";
   exec sql declare praxis_curs cursor for
   	select name, max_wert, lernfaktor
   	from praxispunkte
   	where not exists (select true from fertigkeiten where name=fertigkeit)
   	order by name;
   exec sql open praxis_curs;
   SQLerror::test(__FILELINE__);
  while (true)
  {exec sql fetch praxis_curs into sql descriptor spalten;
   SQLerror::test(__FILELINE__,100);
   if (sqlca.sqlcode) break;
   FetchIStream is("spalten");
   o << "  <Steigern";
   fetch_and_write_string_attrib(is, o, "Name");
   fetch_and_write_int_attrib(is, o, "MaximalWert");
   fetch_and_write_int_attrib(is, o, "Lernfaktor");
   o << "/>\n";
  }
   exec sql close praxis_curs;
   SQLerror::test(__FILELINE__);
   o << " </Praxispunkte>\n";

//********************* ZEP oder KEP oder beides? ********************
  {o << " <verwendbareEP>\n";
   o << "    <-- hier stehen nur die Dinge, die nicht schon Fertigkeiten sind -->\n";
   exec sql declare mit_curs cursor for
   	select name, ep
   	from steigern_fertigkeiten_mit
   	where not exists (select true from fertigkeiten where name=fertigkeit)
   	order by name,ep;
   exec sql open mit_curs;
   SQLerror::test(__FILELINE__);
   std::string fert,ep;
  while (true)
  {exec sql begin declare section;
   char NAME[100];
   char EP[8];
   exec sql end declare section;
   
   exec sql fetch mit_curs into :NAME, :EP;
   SQLerror::test(__FILELINE__,100);
   if (sqlca.sqlcode) break;
   if (fert!=NAME)
   {  if (ep.size())
         o << "  <EP-Typ Fertigkeit=\"" << toXML(fert) 
      		<< "\" Typ=\"" << toXML(ep.substr(1)) << "\"/>\n";
      fert=NAME;
      ep="";
   }
   ep+=string(",")+EP;
  }
  if (ep.size()) 
         o << "  <EP-Typ Fertigkeit=\"" << toXML(fert) 
      		<< "\" Typ=\"" << toXML(ep.substr(1)) << "\"/>\n";
 }
   exec sql close mit_curs;
   SQLerror::test(__FILELINE__);
   o << " </verwendbareEP>\n";

//*************************** Steigerungstabelle *******************
   o << " <SteigernKosten>\n";
   exec sql declare curs_steig cursor for
      		select name,
      	    coalesce(p0,0), coalesce(p1,0), coalesce(p2,0), coalesce(p3,0),
      	    coalesce(p4,0), coalesce(p5,0), coalesce(p6,0), coalesce(p7,0),
      	    coalesce(p8,0), coalesce(p9,0), coalesce(p10,0), coalesce(p11,0),
      	    coalesce(p12,0), coalesce(p13,0), coalesce(p14,0), coalesce(p15,0),
      	    coalesce(p16,0), coalesce(p17,0), coalesce(p18,0), coalesce(p19,0),
      	    coalesce(p20,0), coalesce(p21,0), coalesce(p22,0), coalesce(p23,0),
      	    coalesce(p24,0), coalesce(p25,0), coalesce(p26,0), coalesce(p27,0),
      	    coalesce(p28,0)
       		from steigern_fertigkeiten_werte
   	where not exists (select true from fertigkeiten where name=fertigkeit)
       		order by name;
   exec sql open curs_steig;
   SQLerror::test(__FILELINE__);
   std::string fert,ep;
  while (true)
       {  exec sql fetch curs_steig into sql descriptor spalten;
          SQLerror::test(__FILELINE__,100);
          if (sqlca.sqlcode) break;
          FetchIStream is("spalten");
          o << "    <Kosten";
          fetch_and_write_string_attrib(is, o, "Fertigkeit");
          for (int i=0;i<=28;++i) 
             fetch_and_write_int_attrib(is, o, "Wert"+itos(i));
          o << "/>\n";
       }
    exec sql close curs_steig;
    SQLerror::test(__FILELINE__);
   o << " </SteigernKosten>\n";

//******************************************************************
   
   exec sql deallocate descriptor spalten;
}

#ifndef XML_NO_MAIN
int main(int argc, char *argv[])
{  
   try{
      Petig::Connection conn;
      conn.setDbase("midgard");
      Petig::dbconnect(conn);

   std::cout << "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n\n";
   std::cout << "<MidgardCG-data>\n";
   fert_speichern(std::cout);
   std::cout << "</MidgardCG-data>\n";
   Petig::dbdisconnect();
   } catch (SQLerror &e)
   {  std::cerr << e << '\n';
   }
   return 0;
}
#endif
