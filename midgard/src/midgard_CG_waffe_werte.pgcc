/*  Midgard Character Generator
 *  Copyright (C) 2001 Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include "midgard_CG.hh"
#include <Aux/Transaction.h>
#include <Aux/SQLerror.h>
#include <Gtk_OStream.h>
exec sql include sqlca;
int swk(std::vector<H_Data_waffen>& vec_Waffen);


std::string midgard_CG::waffe_werte(const H_Data_waffen& Waffe,const Grundwerte& Werte, const std::string& mod)
{
  exec sql begin declare section;
   char db_waffe[50];
   char db_art[50];
   char db_s1[50] ;
   int  db_sb ;
   char db_angriffsrangmod[10], db_wm_abwehr_leicht[10], db_wm_abwehr_schwer[10];
   int db_reich_0,db_reich_n,db_reich_m,db_reich_f;
  exec sql end declare section;
  strncpy(db_waffe,(Waffe->Name()).c_str(),sizeof(db_waffe));
  exec sql select coalesce(schaden,''), coalesce(schaden_b,0),
      art, coalesce(angriffsrangmod,''), coalesce(wm_abwehr_leicht,''),
      coalesce(wm_abwehr_schwer,''),coalesce(reichweite_0,-1)
      ,coalesce(reichweite_n,-1),coalesce(reichweite_m,-1),coalesce(reichweite_f,-1)
      into :db_s1, :db_sb, :db_art, :db_angriffsrangmod,
            :db_wm_abwehr_leicht, :db_wm_abwehr_schwer,
            :db_reich_0, :db_reich_n, :db_reich_m, :db_reich_f
      from waffen where name = :db_waffe;
  SQLerror::test(__FILELINE__);
  std::string art=db_art;
  if (mod=="Verteidigung")
   {
      if (art=="Verteidigung") return "true";
      else return "false";
   }
  if (mod=="Angriffsrangmodifikation")
   {
      std::string anm = db_angriffsrangmod;
      return anm;
   }
  if (mod=="WM_Abwehr")
   {
      std::string abl = db_wm_abwehr_leicht;
      std::string abs = db_wm_abwehr_schwer;
      if (abl==""&&abs=="") return "";
      else return abl+"$|$"+abs;
   }
  if (mod=="Angriffsrangmodifikation")
   {
      std::string ret = db_angriffsrangmod;
      return ret;
   }
  if (mod=="Schaden" || mod=="Schaden+mag_Bonus")
   {
     if (art=="Verteidigung") return "-"+itos(db_sb)+"AP"; /* doppeltes Minus wg. LaTeX Ausdruck */
     std::string schaden = db_s1;
     if (schaden=="0") return "";
     if (Waffe->Name()=="waffenloser Kampf") {schaden="W6"; db_sb=swk(vec_Waffen);}

     int ibonus = db_sb;
     if (art!="Fern") ibonus+=Werte.bo_Sc();
     if (mod=="Schaden+mag_Bonus")
      {  ibonus += Waffe->sl_Bonus();
         if (Waffe->sl_Bonus() ==-5 && Waffe->av_Bonus() ==-5) ibonus -= Waffe->sl_Bonus(); 
      }
     if (ibonus < 0 ) schaden += "-"+itos(ibonus); /* doppeltes Minus für LaTeX Ausdruck */
     if (ibonus == 0 ) schaden += "";
     if (ibonus > 0 ) schaden += "+"+itos(ibonus);
     return schaden;
   }
 if (mod=="Fern")
   {
     if (db_reich_0==-1) return ""; // keine Fernkampfwaffe
     std::string s = itos(db_reich_0)+"/"+itos(db_reich_n)+"/"
              + itos(db_reich_m)+"/"+itos(db_reich_f); 
     return s; 
   }
 abort();
}

int swk(std::vector<H_Data_waffen>& vec_Waffen) 
/*Schaden für waffenlosen Kampf*/
{
   int wert = 4;
   for (std::vector<H_Data_waffen>::const_iterator i=vec_Waffen.begin();
         i!=vec_Waffen.end();++i)
     if ((*i)->Name() == "waffenloser Kampf") 
      { wert=(*i)->Erfolgswert(); break;}

   int bo ;
   if ( 4<=wert && wert <= 7) bo=-4;
   if ( 8<=wert && wert <=11) bo=-3;
   if (12<=wert && wert <=15) bo=-2;
   if (16<=wert) bo=-1;
   return bo;
}
