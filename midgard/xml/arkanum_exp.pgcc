// $Id: arkanum_exp.pgcc,v 1.15 2001/11/14 15:47:21 christof Exp $
/*  Midgard Roleplaying Character Generator
 *  Copyright (C) 2001 Christof Petig
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <fstream>
#include <Aux/Transaction.h>
#include <Aux/dbconnect.h>
exec sql include sqlca;
#include "export_common.h"

// wegen eines bugs in epcg <=V6.1
#define GARNIX 

void arkanum_speichern(std::ostream &o)
{  
   Transaction t;
   exec sql allocate descriptor spalten;
   exec sql declare zauber_curs cursor for
   	select name, region, stufe, kosten, ap, art, 
   	ursprung, agens, prozess, reagens,
   	zauberdauer, reichweite, wirkungsziel, wirkungsbereich,
   	wirkungsdauer, material, 
   	zauberart, element, spruchrolle, thaumagram
   	from zauber
   	order by coalesce(region,''),name;
   exec sql open zauber_curs;
   SQLerror::test(__FILELINE__);
   o << "<MidgardCG-data>\n";
  while (true)
  {exec sql fetch zauber_curs into sql descriptor spalten;
   SQLerror::test(__FILELINE__,100);
   if (sqlca.sqlcode) break;
   FetchIStream is("spalten");
   o << "  <Spruch";
   string zauber=fetch_and_write_string_attrib(is, o, "Name");
   fetch_and_write_string_attrib(is, o, "Region");
   fetch_and_write_string_attrib(is, o, "Grad");
   fetch_and_write_int_attrib(is, o, "Lernkosten");
   fetch_and_write_string_attrib(is, o, "AP");
   fetch_and_write_string_attrib(is, o, "Typ");
   fetch_and_write_string_attrib(is, o, "Ursprung");
   fetch_and_write_string_attrib(is, o, "Agens");
   fetch_and_write_string_attrib(is, o, "Prozess");
   fetch_and_write_string_attrib(is, o, "Reagens");
   fetch_and_write_string_attrib(is, o, "Zauberdauer");
   fetch_and_write_string_attrib(is, o, "Reichweite");
   fetch_and_write_string_attrib(is, o, "Wirkungsziel");
   fetch_and_write_string_attrib(is, o, "Wirkungsbereich");
   fetch_and_write_string_attrib(is, o, "Wirkungsdauer");
   fetch_and_write_string_attrib(is, o, "Material");
   fetch_and_write_string_attrib(is, o, "Zauberart");
   fetch_and_write_string_attrib(is, o, "Element");
   fetch_and_write_bool_attrib(is, o, "Spruchrolle");
   fetch_and_write_string_attrib(is, o, "Thaumagramm");
   o << ">\n";
   {  exec sql begin declare section;
      const char *ZAUBER=zauber.c_str(GARNIX);
      char TYPEN[40][40];
      exec sql end declare section;
      
      exec sql select typ into :TYPEN from zauber_typen
      	where name=:ZAUBER and standard='G'
      	order by typ;
      if (!sqlca.sqlcode) 
      {  o << "    <Grund>";
         for (int i=0;i<sqlca.sqlerrd[2];++i)
         {  o << typ_standardisierung(TYPEN[i]);
            if (i+1 < sqlca.sqlerrd[2]) o << ',';
         }
         o << "</Grund>\n";
      }
      exec sql select typ into :TYPEN from zauber_typen
      	where name=:ZAUBER and standard='S'
      	order by typ;
      if (!sqlca.sqlcode) 
      {  o << "    <Standard>";
         for (int i=0;i<sqlca.sqlerrd[2];++i)
         {  o << typ_standardisierung(TYPEN[i]);
            if (i+1 < sqlca.sqlerrd[2]) o << ',';
         }
         o << "</Standard>\n";
      }
      exec sql select typ into :TYPEN from zauber_typen
      	where name=:ZAUBER and standard='A'
      	order by typ;
      if (!sqlca.sqlcode) 
      {  o << "    <Ausnahme>";
         for (int i=0;i<sqlca.sqlerrd[2];++i)
         {  o << typ_standardisierung(TYPEN[i]);
            if (i+1 < sqlca.sqlerrd[2]) o << ',';
         }
         o << "</Ausnahme>\n";
      }

      // wert, attribut, [p+s]_element 
      exec sql declare cursor_lp cursor for 
      	select typ,lernpunkte,pflicht,p_element,s_element from lernschema 
      	where fertigkeit=:ZAUBER and art='Zauber'
      	order by lernpunkte,typ;
      exec sql open cursor_lp;
      while (!sqlca.sqlcode) 
      {  exec sql fetch from cursor_lp into sql descriptor spalten;
         if (sqlca.sqlcode) break;
         FetchIStream is2("spalten");
         o << "    <Lernschema";
         fetch_and_write_typ_attrib(is2, o, "Typ");
         fetch_and_write_int_attrib(is2, o, "Lernpunkte");
         fetch_and_write_bool_attrib(is2, o, "Pflicht");
         fetch_and_write_string_attrib(is2, o, "Primärelement");
         fetch_and_write_string_attrib(is2, o, "Sekundärelement");
         o << "/>\n";
      }
      exec sql close cursor_lp;
      
/* 7.2      ex ec sql select beschreibung into descriptor spalten 
      	from zauber_beschreibung where name=:ZAUBER 
      	and beschreibung is not null and beschreibung!=''; */
      exec sql declare cursor_b cursor for 
      	select beschreibung from zauber_beschreibung 
      	where name=:ZAUBER and beschreibung is not null and beschreibung!='';
      exec sql open cursor_b;
      if (!sqlca.sqlcode) exec sql fetch from cursor_b into sql descriptor spalten;
      if (!sqlca.sqlcode)
      {  FetchIStream is2("spalten");
         fetch_and_write_string(is2,o,"Beschreibung",4);
      }
      exec sql close cursor_b;
   }
   o << "  </Spruch>\n";
  }
   exec sql close zauber_curs;
   SQLerror::test(__FILELINE__);
   
   //***************** Zauberwerk ********************************

   exec sql declare zauberwerk_curs cursor for
   	select name, region, art, stufe, zeitaufwand, kosten, kosten_gfp
   	from zauberwerk
   	order by coalesce(region,''),name;
   exec sql open zauberwerk_curs;
   SQLerror::test(__FILELINE__);
  while (true)
  {exec sql fetch zauberwerk_curs into sql descriptor spalten;
   SQLerror::test(__FILELINE__,100);
   if (sqlca.sqlcode) break;
   FetchIStream is("spalten");
   o << "  <Zauberwerk";
   string zauberwerk=fetch_and_write_string_attrib(is, o, "Name");
   fetch_and_write_string_attrib(is, o, "Region");
   fetch_and_write_string_attrib(is, o, "Art");
   string stufe=fetch_and_write_string_attrib(is, o, "Stufe");
   fetch_and_write_string_attrib(is, o, "Zeitaufwand");
   fetch_and_write_string_attrib(is, o, "Geldaufwand");
   fetch_and_write_string_attrib(is, o, "Kosten");
   o << ">\n";
   {  exec sql begin declare section;
      const char *ZAUBERWERK=zauberwerk.c_str(GARNIX);
      char TYPEN[40][40];
      const char *STUFE=stufe.c_str(GARNIX);
      exec sql end declare section;
      
      exec sql select typ into :TYPEN from zauberwerk_typen
      	where name=:ZAUBERWERK and standard='G' and stufe=:STUFE
      	order by typ;
      if (!sqlca.sqlcode) 
      {  o << "    <Grund>";
         for (int i=0;i<sqlca.sqlerrd[2];++i)
         {  o << typ_standardisierung(TYPEN[i]);
            if (i+1 < sqlca.sqlerrd[2]) o << ',';
         }
         o << "</Grund>\n";
      }
      exec sql select typ into :TYPEN from zauberwerk_typen
      	where name=:ZAUBERWERK and standard='S' and stufe=:STUFE
      	order by typ;
      if (!sqlca.sqlcode) 
      {  o << "    <Standard>";
         for (int i=0;i<sqlca.sqlerrd[2];++i)
         {  o << typ_standardisierung(TYPEN[i]);
            if (i+1 < sqlca.sqlerrd[2]) o << ',';
         }
         o << "</Standard>\n";
      }
      exec sql select typ into :TYPEN from zauberwerk_typen
      	where name=:ZAUBERWERK and standard='A' and stufe=:STUFE
      	order by typ;
      if (!sqlca.sqlcode) 
      {  o << "    <Ausnahme>";
         for (int i=0;i<sqlca.sqlerrd[2];++i)
         {  o << typ_standardisierung(TYPEN[i]);
            if (i+1 < sqlca.sqlerrd[2]) o << ',';
         }
         o << "</Ausnahme>\n";
      }
      // Zauberwerk Voraussetzungen
      exec sql declare zaubwerk_vor_curs cursor for 
      	select voraussetzung,verbindung from zauberwerk_voraussetzung 
      	where name=:ZAUBERWERK
      	order by voraussetzung;
      exec sql open zaubwerk_vor_curs;
      while (!sqlca.sqlcode) 
      {  exec sql fetch from zaubwerk_vor_curs into sql descriptor spalten;
         if (sqlca.sqlcode) break;
         FetchIStream is2("spalten");
         o << "    <Voraussetzung";
         fetch_and_write_string_attrib(is2, o, "Fertigkeit");
         fetch_and_write_string_attrib(is2, o, "Verbindung");
         o << "/>\n";
      }
      exec sql close zaubwerk_vor_curs;
   }
   o << "  </Zauberwerk>\n";
  }
   exec sql close zauberwerk_curs;
   SQLerror::test(__FILELINE__);

//*************************************************************   
   o << "</MidgardCG-data>\n";
   
   exec sql deallocate descriptor spalten;
}

int main(int argc, char *argv[])
{  
   try{
      Petig::Connection conn;
      conn.setDbase("midgard");
      Petig::dbconnect(conn);

   std::cout << "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n\n";
   arkanum_speichern(std::cout);
   Petig::dbdisconnect();
   } catch (SQLerror &e)
   {  std::cerr << e << '\n';
   }
   return 0;
}
