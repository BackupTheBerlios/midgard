/*  Midgard Character Generator
 *  Copyright (C) 2001 Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include "midgard_CG.hh"
#include <Aux/Transaction.h>
#include <Aux/SQLerror.h>
exec sql include sqlca;
#include <cstring>
//#include <Gtk_OStream.h>
//#include <algorithm>
#include "WindowInfo.hh"
#include <Aux/EntryValueIntString.h>
#include <Aux/EntryValueEmptyInt.h>


void midgard_CG::on_fertigkeiten_laden_clicked()
{
  midgard_CG::on_speichern_clicked();
  midgard_CG::show_alte_fertigkeiten();
  midgard_CG::show_neue_fertigkeiten();
   
}


class Data_alt_fert : public RowDataBase
{
   string name;
   int wert, steigern, reduzieren, verlernen;
 public:
   Data_alt_fert(const string& n, int w,int s,int r,int v )
   :name(n),wert(w),steigern(s),reduzieren(r),verlernen(v) {}

   virtual const cH_EntryValue Value(int seqnr) const
 { switch (seqnr) {
      case 0 : return cH_EntryValueIntString(name);
      case 1 : return cH_EntryValueEmptyInt(wert);
      case 2 : return cH_EntryValueEmptyInt(steigern);
      case 3 : return cH_EntryValueEmptyInt(reduzieren);
      case 4 : return cH_EntryValueEmptyInt(verlernen);
   }
   return cH_EntryValueIntString("?");
 }
 string Name() const {  return name; }
 int  Wert() const {  return wert; }
 int  Steigern() const {  return steigern; }
 int  Reduzieren() const {  return reduzieren; }
 int  Verlernen() const {  return verlernen; }

};

void midgard_CG::on_leaf_selected_alte_fert(cH_RowDataBase d)
{  const Data_alt_fert *dt=dynamic_cast<const Data_alt_fert*>(&*d);
   on_steigern_fert_tree_alt_select(dt->Name(),dt->Wert(),dt->Steigern(),
      dt->Reduzieren(),dt->Verlernen());
}
 

void midgard_CG::show_alte_fertigkeiten()
{
   vector<cH_RowDataBase> datavec;
   for ( vector<st_ausgewaehlte_fertigkeiten>::iterator i=vec_fertigkeiten.begin();i!=vec_fertigkeiten.end();++i)
      {
        exec sql begin declare section;
          int db_kosten_steigern=0, db_kosten_reduzieren=0, db_fp;
          char query[1024];
          char db_standard[5],db_standard2[5];
        exec sql end declare section;
        string squery;

        if (i->erfolgswert != 0) // Fertigkeiten MIT Erfolgswert
         {
           squery = "SELECT coalesce(p"+itos(abs(i->erfolgswert))
               +",0),coalesce(p"+itos(abs(i->erfolgswert+1))+",0),fp,f."+typ.s;
           if (typ_2.s!="") squery += ", "+typ_2.s;
           squery +=" FROM steigern_fertigkeiten s, steigern_fertigkeiten_werte w, \
               fertigkeiten f WHERE s.name = '"+i->name+"' AND w.name = s.wie \
               AND f.fertigkeit = '"+i->name+"'";
         }
        else // Fertigkeiten OHNE Erfolgswert
         {
           squery = "SELECT fp,f."+typ.s;
           if (typ_2.s!="") squery += ", "+typ_2.s;
           squery  +=" FROM steigern_fertigkeiten s, fertigkeiten f \
               WHERE s.name = '"+i->name+"' \
               AND f.fertigkeit = '"+i->name+"'";
         }
        strncpy(query,squery.c_str(),sizeof(query));

        Transaction tr;
        exec sql prepare kosten_ein_ from :query ;  
        exec sql declare kosten_ein cursor for kosten_ein_ ;  
        exec sql open kosten_ein;
        if(typ_2.s!="")      
         {
           if (i->erfolgswert != 0) // Fertigkeiten MIT Erfolgswert
               exec sql fetch kosten_ein into :db_kosten_reduzieren, 
                    :db_kosten_steigern, :db_fp, :db_standard,:db_standard2;
           else // Fertigkeiten OHNE Erfolgswert
               exec sql fetch kosten_ein into :db_fp, :db_standard,:db_standard2;
         }
        else
         {
           if (i->erfolgswert != 0) // Fertigkeiten MIT Erfolgswert
               exec sql fetch kosten_ein into :db_kosten_reduzieren, 
                    :db_kosten_steigern, :db_fp, :db_standard;
           else // Fertigkeiten OHNE Erfolgswert
               exec sql fetch kosten_ein into :db_fp, :db_standard;
         }
        SQLerror::test(__FILELINE__);
        exec sql close kosten_ein;
        tr.close();

        double fac = midgard_CG::get_standard_fertigkeit_(db_standard,db_standard2,i->name);
        datavec.push_back(new Data_alt_fert(i->name,
                  i->erfolgswert,db_kosten_steigern*fac,
                  db_kosten_reduzieren*fac,db_fp * fac));
      }
 alte_fert_tree->setDataVec(datavec);  
}



class Data_neu_fert : public RowDataBase
{
   string name;
   int wert, lernkosten;
   string art,vorraussetzungen;
 public:
   Data_neu_fert(const string& n, int w,int l,string a, string v )
   :name(n),wert(w),lernkosten(l),art(a),vorraussetzungen(v) {}

   virtual const cH_EntryValue Value(int seqnr) const
 { switch (seqnr) {
      case 0 : return cH_EntryValueIntString(name);
      case 1 : return cH_EntryValueEmptyInt(wert);
      case 2 : return cH_EntryValueEmptyInt(lernkosten);
      case 3 : return cH_EntryValueIntString(art);
      case 4 : return cH_EntryValueIntString(vorraussetzungen);
   }
   return cH_EntryValueIntString("?");
 }
 string Name() const {  return name; }
 int  Wert() const {  return wert; }
 int  Lernkosten() const {  return lernkosten; }
// string  Art() const {  return art; }
// string  Vorraussetzungen() const {  return vorraussetzungen; }

};
void midgard_CG::on_leaf_selected_neue_fert(cH_RowDataBase d)
{  const Data_neu_fert *dt=dynamic_cast<const Data_neu_fert*>(&*d);
   cout << "Data " << dt->Name() << '\n'; 
   cout << "Data " << dt->Wert() << '\n'; 
   on_steigern_fert_tree_neu_select(dt->Name(),dt->Wert(),dt->Lernkosten());
}


void midgard_CG::show_neue_fertigkeiten()
{
  vector<cH_RowDataBase> datavec;
  exec sql begin declare section;
   char db_fertigkeiten[100];
   int db_erfolgswert; 
   char db_standard[5],db_standard2[5];
   int db_fp;
   char query[1024];
   char db_voraussetzung[100];
   char db_region[10];
  exec sql end declare section;
  string squery = "SELECT f.fertigkeit, f.fp, coalesce(f.anfangswert,''), \
   coalesce(f."+typ.s+",''), ";
  if (typ_2.s!="") squery += " coalesce(f."+typ_2.s+",''), ";
  squery += "coalesce(v.fertigkeit,''), coalesce(f.region,'') \
   FROM fertigkeiten f, fertigkeiten_voraussetzung v WHERE \
   v.name = f.fertigkeit \
   AND f.fertigkeit NOT IN (SELECT fertigkeit FROM charaktere_fertigkeiten \
   WHERE charakter_name = '"+werte.name_charakter+"' \
   AND version = '"+werte.version+"') \
   AND f.fertigkeit != 'Sprache' AND f.fertigkeit != 'Lesen/Schreiben' \
   AND f.fertigkeit  not in (select verboten from pflicht_lernen where \
    typ='"+werte.spezies+"'  and spielbegin is null) \
   AND fp is not null
   ORDER BY f.fertigkeit";

  strncpy(query,squery.c_str(),sizeof(query));

 Transaction tr;  
 exec sql prepare fert_ein_ from :query ;  
 exec sql declare fert_ein cursor for fert_ein_ ;  
 exec sql open fert_ein;
 SQLerror::test(__FILELINE__);
 while (true)
   {
      if (typ_2.s!="")
         exec sql fetch fert_ein into :db_fertigkeiten, :db_fp, 
            :db_erfolgswert, :db_standard, :db_standard2, :db_voraussetzung, 
            :db_region;
      else
         exec sql fetch fert_ein into :db_fertigkeiten, :db_fp, 
            :db_erfolgswert, :db_standard, :db_voraussetzung, 
            :db_region;
      SQLerror::test(__FILELINE__,100);  
      if (sqlca.sqlcode) break;
      double fac = midgard_CG::get_standard_fertigkeit_(db_standard,db_standard2,db_fertigkeiten);
      string s1 = db_standard, s2 = db_standard2;
      s1 = Ausnahmen_string(db_fertigkeiten,db_standard,"");
//cout << "\t\t"<<s1<<"\t"<<fac<<"\n";
//cout << db_fertigkeiten<<"\t"<<Fertigkeiten_Voraussetzung(db_fertigkeiten)
//      <<"\t->"<<db_region<<"<-\t"<<BRbool<<"\t"<<region_check(db_region)<<"\n";
      if (midgard_CG::Fertigkeiten_Voraussetzung(db_fertigkeiten) 
        &&midgard_CG::region_check(db_region) 
        && (s1!="" || s2!="") )
       {
          string st=(string)db_standard+" "+(string)db_standard2;
          datavec.push_back(new Data_neu_fert(db_fertigkeiten,db_erfolgswert,
               db_fp*fac,st,db_voraussetzung));
       }
   }
 exec sql close fert_ein;
 neue_fert_tree->setDataVec(datavec);
 tr.commit();
}

bool midgard_CG::kido_steigern_check(int wert)
{
  if (werte.grad+10 > wert) return false;
  else
   { string strinfo ="KiDo darf nur auf maximal Grad+10 gesteigert werden.\n";
     manage (new WindowInfo(strinfo));
     return true;
   }
}


void midgard_CG::on_steigern_fert_tree_alt_select(const string& fertigkeit, int wert,
   int steigern,int reduzieren,int verlernen)
{
 if (fertigkeit=="KiDo" && kido_steigern_check(wert)) return;
   if (radio_fert_steigern->get_active())
    {
      // Steigern mit lernen
      if (!togglebutton_praxispunkte_fertigkeiten->get_active()) 
         {
            werte.gfp += steigern;
            if (steigern != 0)
            for (vector<st_ausgewaehlte_fertigkeiten>::iterator i=vec_fertigkeiten.begin();
                     i!= vec_fertigkeiten.end();++i )
               if ( i->name == fertigkeit) i->erfolgswert++; 
         }
      else  // Lernen mit Praxispunkten 
         {
            bool wuerfeln;
            if (radiobutton_praxis_wuerfeln_fertigkeiten->get_active()) wuerfeln = true;
            if (radiobutton_praxis_auto_fertigkeiten->get_active()) wuerfeln = false;
            int gelungen = midgard_CG::praxispunkte_wuerfeln(fertigkeit,wert,"Fertigkeit",wuerfeln);
            if (gelungen)
               {
                  werte.gfp += steigern/2;
                  for (vector<st_ausgewaehlte_fertigkeiten>::iterator i=vec_fertigkeiten.begin();
                        i!= vec_fertigkeiten.end();++i )
                     if ( i->name == fertigkeit) i->erfolgswert++; 
               }
         }     
    }
   if (radio_fert_reduzieren->get_active())
         {
            werte.gfp -= reduzieren;
            if (reduzieren != 0)
            for (vector<st_ausgewaehlte_fertigkeiten>::iterator i=vec_fertigkeiten.begin();
                     i!= vec_fertigkeiten.end();++i )
               if ( i->name == fertigkeit) i->erfolgswert--; 
         }
   if (radio_fert_verlernen->get_active())
         {
            werte.gfp -= verlernen;
            if (verlernen != 0)
            for (vector<st_ausgewaehlte_fertigkeiten>::iterator i=vec_fertigkeiten.begin();
                     i!= vec_fertigkeiten.end();++i )
               if ( i->name == fertigkeit) {vec_fertigkeiten.erase(i);break;}; 
         }
   midgard_CG::zeige_werte(werte,"alle");
   midgard_CG::on_speichern_clicked();
   midgard_CG::show_alte_fertigkeiten();
   midgard_CG::show_neue_fertigkeiten();
}

void midgard_CG::on_steigern_fert_tree_neu_select(const string& fertigkeit, int wert, int lernkosten)
{
  werte.gfp += lernkosten;
  midgard_CG::zeige_werte(werte,"alle");
  vec_fertigkeiten.push_back(st_ausgewaehlte_fertigkeiten(fertigkeit,wert,"0"));

  if (fertigkeit=="KiDo") {kido_bool=true;show_gtk(get_typ_nr());
      string strinfo="Jetzt muß ein Stil unter 'Lernschema' -> 'KiDo' gewählt werden !!!";
      manage (new WindowInfo(strinfo,true)); }
  if (fertigkeit=="Wissen von der Magie") 
      {  midgard_CG::doppelcharaktere();
         string strinfo ="Jetzt unter 'Grundwerte' die zweite Charkakterklasse wählen\n";
         manage (new WindowInfo(strinfo,true));
         // Resistenzboni für Zauberer setzten:
         werte.bo_psy += 3;
         werte.bo_phs += 1;
         werte.bo_phk += 3;
         if (werte.zaubern_wert=="") werte.zaubern_wert = "10";
      }

  midgard_CG::show_fertigkeiten();
  midgard_CG::on_speichern_clicked();
  midgard_CG::show_alte_fertigkeiten();
  midgard_CG::show_neue_fertigkeiten();

}

void midgard_CG::on_radio_fert_steigern_toggled()
{
}

void midgard_CG::on_radio_fert_reduzieren_toggled()
{
   if (radio_fert_reduzieren->get_active())
      togglebutton_praxispunkte_fertigkeiten->set_active(false);
}

void midgard_CG::on_radio_fert_verlernen_toggled()
{
   if (radio_fert_verlernen->get_active())
      togglebutton_praxispunkte_fertigkeiten->set_active(false);
}

void midgard_CG::on_togglebutton_praxispunkte_fertigkeiten_toggled()
{
    if (togglebutton_praxispunkte_fertigkeiten->get_active())
      radio_fert_steigern->set_active(true);

}

void midgard_CG::on_radiobutton_praxis_wuerfeln_fertigkeiten_toggled()
{
}

void midgard_CG::on_radiobutton_praxis_auto_fertigkeiten_toggled()
{
}

bool midgard_CG::Fertigkeiten_Voraussetzung(const string& fertigkeit)
{
  exec sql begin declare section;
   int db_st,db_ge,db_ko,db_in,db_zt,db_pa,db_au,db_sb,db_rw;
   char db_fertigkeit[30], db_fert[30];
  exec sql end declare section;
  strncpy(db_fertigkeit,fertigkeit.c_str(),sizeof(db_fertigkeit));

  exec sql select distinct coalesce(st,'0'), coalesce(ge,'0'),
   coalesce(ko,'0'),  coalesce("in",'0'), coalesce(zt,'0'),
   coalesce(au,'0'), coalesce(pa,'0'), 
   coalesce(sb,'0'), coalesce(rw,'0'), coalesce(fertigkeit,'')
   into :db_st,:db_ge,:db_ko,:db_in,:db_zt,:db_au,:db_pa,
         :db_sb,:db_rw,:db_fert
   from fertigkeiten_voraussetzung where name= :db_fertigkeit;
//  SQLerror::test(__FILELINE__,100);
  SQLerror::test(__FILELINE__);
    if ( db_st<=werte.st &&
         db_ge<=werte.ge &&
         db_ko<=werte.ko &&
         db_in<=werte.in &&
         db_zt<=werte.zt &&
         db_au<=werte.au &&
         db_pa<=werte.pa &&
         db_sb<=werte.sb &&
         db_rw<=werte.rw
       )   
     return true;
  else return false ;
}
