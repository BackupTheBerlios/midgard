/*  Midgard Character Generator
 *  Copyright (C) 2001 Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

// generated 2001/2/11 14:16:06 CET by thoma@ig23.
// using glademm V0.5_11c
//
// newer (non customized) versions of this file go to Zauber_auswahl.cc_new

// This file is for your program, I won't touch it again!

#include <Aux/Transaction.h>
#include <Aux/SQLerror.h>
exec sql include sqlca;
#include "midgard_CG.hh"
#include <cstring>
#include <Gtk_OStream.h>

#include "class_Ausnahmen.hh"

#ifdef __MINGW32__
extern "C" { int snprintf(char *str, size_t size, const  char  *format, ...); }
#endif

double midgard_CG::get_standard_zauber(const H_Data_typen& Typ, const H_Data_typen& Typ2, const std::string& zauber)
{
   Ausnahmen ausnahmen(Werte,Typ,Typ2,vec_Beruf);
   double fac;
   // gibt es eine Ausnahmeregelung?
//   fac = midgard_CG::Ausnahmen_float(zauber);
   fac = ausnahmen.Ausnahmen_float(zauber);
   if (fac!=0) return fac;

   //sonst
  exec sql begin declare section;
   char db_ergebnis[20], db_ergebnis2[20];
   char db_p_element[50],db_s_element[50];
   char query[200];
  exec sql end declare section;
  strncpy(db_ergebnis2,"",sizeof(db_ergebnis2));
  strncpy(db_p_element,"",sizeof(db_p_element));
  strncpy(db_s_element,"",sizeof(db_s_element));
 
  std::string squery = "select ";
  if (get_typ_s("Magie",Typ)) squery += " coalesce("+Typ->Short()+",'A')"; 
  if (get_typ_s("Magie",Typ) && get_typ_s("Magie",Typ2)) squery += ", ";
  if (get_typ_s("Magie",Typ2)) squery += " coalesce("+Typ2->Short()+",'A')";
  if (Typ->Short()=="eBe" || Typ2->Short()=="eBe") squery += " , coalesce(p_element,'') , coalesce(s_element,'') "; 
  squery += " from arkanum_zauber where name = '"+zauber+"'";
  strncpy(query,squery.c_str(),sizeof(query));  

/*
  if (typ!="eBe")
     snprintf(query,sizeof(query),"select coalesce(%s,'A') from arkanum_zauber where name = '%s'",
               typ.c_str(), zauber.c_str());
  if (typ=="eBe")
     snprintf(query,sizeof(query),"select coalesce(%s,'A'), coalesce(p_element,''), \
               coalesce(s_element,'') from arkanum_zauber where name = '%s'", \
               typ.c_str(), zauber.c_str());
*/

//std::cout << query<<"\n";
   Transaction tr;
   exec sql prepare zaub from :query ;    
   exec sql declare zauber cursor for zaub ;
   exec sql open zauber;
   SQLerror::test(__FILELINE__);
//std::cout << Typ->Short()<<"\t"<<Typ2->Short()<<"\n";
   if(get_typ_s("Magie",Typ) && get_typ_s("Magie",Typ2) ) 
    { if (Typ->Short() !="eBe" && Typ2->Short() !="eBe") exec sql fetch zauber into  :db_ergebnis,:db_ergebnis2;
      else exec sql fetch zauber into  :db_ergebnis,:db_ergebnis2,:db_p_element,:db_s_element;
    }
   else 
    { if (Typ->Short() !="eBe" &&  Typ2->Short() !="eBe") exec sql fetch zauber into  :db_ergebnis;
      if (Typ->Short() =="eBe" ||  Typ2->Short() =="eBe") exec sql fetch zauber into  :db_ergebnis,:db_p_element,:db_s_element;
    }
   SQLerror::test(__FILELINE__);  

   fac = get_standard_zauber_(db_ergebnis,db_ergebnis2,db_p_element,db_s_element,zauber);
//std::cout << typ << "\t"<<zauber<<"\t"<<db_ergebnis<<"\t"<<fac<<"\n";
   return(fac);
}

double midgard_CG::get_standard_zauber_(const std::string& ergebnis,const std::string& ergebnis2, 
   const std::string& p_element, const std::string& s_element, const std::string& zauber)
{
   Ausnahmen ausnahmen(Werte,Typ,Typ2,vec_Beruf);
   double fac;
   // gibt es eine Ausnahmeregelung?
   fac = ausnahmen.Ausnahmen_float(zauber);
   if (fac!=0) return fac;

   if (Typ->Short() != "eBe" || (p_element=="" && s_element==""))
      {
         if      (ergebnis=="G" || ergebnis2=="G") fac = 0.5; 
         else if (ergebnis=="S" && ( ergebnis2=="S" || ergebnis2=="" )) fac = 1.0; 
         else if (ergebnis2=="S" && ( ergebnis=="S" || ergebnis=="" )) fac = 1.0; 
         else fac = 5.0; 
      }
   else
      {
         if (p_element==Werte.Spezial())  fac = 0.5;
         if (s_element==Werte.Spezial2()) fac = 1;
         else fac = 0;
      }
   return(fac);
}

