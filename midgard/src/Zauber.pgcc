#include "Zauber.hh"
#include "midgard_CG.hh"
#include <Aux/SQLerror.h>
#include <Aux/Transaction.h>
#include "Typen.hh"
exec sql include sqlca;
#include <xml.h>

cH_Zauber::cache_t cH_Zauber::cache;

cH_Zauber::cH_Zauber(const std::string& name)
{
// st_index index(name);
 cH_Zauber *cached(cache.lookup(name));
 if (cached) *this=*cached;
 else
  {
   *this=cH_Zauber(new Zauber(name));
   cache.Register(name,*this);
  }
}

void Zauber::get_Zauber()
{
#ifndef USE_XML
  exec sql begin declare section;
   char db_ursprung[50];
   int db_kosten;
   char db_stufe[10];
   char query[1000];
   char db_region[10];
   char db_zauberart[30];
   char db_element[30];
   char db_ap[10], db_art[20], db_agens[30], db_prozess[30], 
        db_reagens[30], db_zauberdauer[30], db_reichweite[10],
        db_wirkungsziel[30], db_wirkungsbereich[30], db_wirkungsdauer[20], 
        db_material[50], db_thaumagram[10];
   bool db_spruchrolle;
  exec sql end declare section;
  
  std::string squery = "SELECT coalesce(z.ursprung,''), 
      z.kosten, z.stufe, z.spruchrolle, coalesce(z.region,''), 
      coalesce(z.zauberart,''), 
      coalesce(z.element,''), z.ap, z.art, coalesce(z.agens,''),
      coalesce(z.prozess,''), coalesce(z.reagens,''),z.zauberdauer,
      z.reichweite,z.wirkungsziel,z.wirkungsbereich,
      z.wirkungsdauer,coalesce(z.material),coalesce(z.thaumagram,'')
      FROM zauber z WHERE name = '"+name+"'";
   strncpy(query,squery.c_str(),sizeof(query));
   Transaction tr;
   exec sql prepare cl_zauber_ein_ from :query ;
   exec sql declare cl_zauber_ein cursor for cl_zauber_ein_ ;

//cout << query<<'\n';
   exec sql open cl_zauber_ein;
   SQLerror::test(__FILELINE__);
   exec sql fetch cl_zauber_ein into :db_ursprung, :db_kosten,
      :db_stufe,  :db_spruchrolle, :db_region, :db_zauberart,
      :db_element, :db_ap, :db_art, :db_agens,
      :db_prozess, :db_reagens, :db_zauberdauer, :db_reichweite,
      :db_wirkungsziel, :db_wirkungsbereich, :db_wirkungsdauer, 
      :db_material, :db_thaumagram;
   SQLerror::test(__FILELINE__);

   ursprung=db_ursprung;   
   kosten=db_kosten;
   stufe=db_stufe;
   spruchrolle=db_spruchrolle;
   region=db_region;
   zauberart=db_zauberart;
   element=db_element;
   ap=db_ap;
   art=db_art;
   stufe=db_stufe;
   zauberdauer=db_zauberdauer;
   reichweite=db_reichweite;
   wirkungsziel=db_wirkungsziel;
   wirkungsbereich=db_wirkungsbereich;
   wirkungsdauer=db_wirkungsdauer;
   ursprung=db_ursprung;
   material=db_material;
   agens=db_agens;
   prozess=db_prozess;
   reagens=db_reagens;
//   beschreibung=db_effekt;
   exec sql close cl_zauber_ein;
   tr.close();
#else // USE_XML
 const Tag *zauber=xml_data->find("Zauber");
 if (!zauber)
    cerr << "<Zauber><Spruch/>... nicht gefunden\n";
 else
 {  Tag::const_iterator b=zauber->begin(),e=zauber->end();
    for (Tag::const_iterator i=zauber->find(b,"Spruch");
    		i!=e;	i=zauber->find(i+1,"Spruch"))
    {  if (i->getAttr("Name")!=name) continue;
       ursprung=i->getAttr("Ursprung");
       kosten=i->getIntAttr("Lernkosten");
       stufe=i->getAttr("Grad");
       spruchrolle=i->getBoolAttr("Spruchrolle");
       region=i->getAttr("Region");
       zauberart=i->getAttr("Zauberart");
       element=i->getAttr("Element");
       ap=i->getIntAttr("AP");;
       art=i->getAttr("Typ");
       zauberdauer=i->getAttr("Zauberdauer");
       reichweite=i->getAttr("Reichweite");
       wirkungsziel=i->getAttr("Wirkungsziel");
       wirkungsbereich=i->getAttr("Wirkungsbereich");
       wirkungsdauer=i->getAttr("Wirkungsdauer");
       material=i->getAttr("Material");
       agens=i->getAttr("Agens");
       prozess=i->getAttr("Prozess");
       reagens=i->getAttr("Reagens");
       return;
    }
 }
#endif   
}

int Zauber::Kosten_eBe(const std::string& pe,const std::string& se) const
{
  double fac; 
    if      (Element() == pe ) fac = 0.5;
    else if (Element() == se ) fac = 1.0;
    else fac = 5.0;  // oder vielleicht null?

  return (int)(fac*GrundKosten());
}

int Zauber::Erfolgswert_Z(const vector<cH_Typen>& Typ,const Grundwerte& Werte,const Ausnahmen& ausnahmen) const
{
   assert(Typ.size()==2);
   int ifac=-2;
   vector<std::string> standard=Standard(Typ,ausnahmen);
   if (standard[0]=="G" || standard[1]=="G") ifac=0;

   int ispez=0;
   if (Typ[0]->Short()=="Ma")
      ispez = get_spezial_zauber_for_magier(Werte,standard[0]);
   if (Typ[1]->Short()=="Ma") 
      ispez = get_spezial_zauber_for_magier(Werte,standard[1]);

//cout << Name()<<' '<<Werte.Zaubern_wert()<<'+'<<Werte.bo_Za()<<'+'<<ifac<<'+'<<ispez<<'=';
   int erf = Werte.Zaubern_wert()+Werte.bo_Za() + ifac + ispez ;
//cout << erf<<'\n';
   return erf;
}

int Zauber::get_spezial_zauber_for_magier(const Grundwerte& Werte,const std::string& standard) const
{
 int ispez=0;
 if (standard!="G" && Agens()==Werte.Spezialgebiet()->Spezial()) ispez = 2;
 if (standard!="G" && Prozess()==Werte.Spezialgebiet()->Spezial()) ispez = 2;
 return ispez;
}


Zauber_All::Zauber_All(Gtk::ProgressBar *progressbar)
{
#ifndef USE_XML
 exec sql begin declare section;
   char db_name[50][100]; 
   int db_size;
 exec sql end declare section;
 exec sql select count(name) into :db_size from zauber;
 exec sql declare ZAein cursor for select distinct name from zauber;
 Transaction tr;
 exec sql open ZAein;
 SQLerror::test(__FILELINE__);
 double count=0;
 while(true)
  {
   exec sql fetch 50 in ZAein into :db_name;
   SQLerror::test(__FILELINE__,100);
//   if (sqlca.sqlcode) break;
   int j=sqlca.sqlerrd[2];
   for (int i=0;i<j;++i)
    {
      progressbar->set_percentage(count/db_size);
      while(Gtk::Main::events_pending()) Gtk::Main::iteration() ;
      list_All.push_back(new Zauber(db_name[i]));
      ++count;
     }
   if(j<50) break;
  }
 exec sql close ZAein;
 tr.close();
#else // USE_XML
 const Tag *zauber=xml_data->find("Zauber");
 int count=0;
 if (!zauber)
    cerr << "<Zauber><Spruch/>... nicht gefunden\n";
 else
 {  Tag::const_iterator b=zauber->begin(),e=zauber->end();
    double size=e-b;
    for (Tag::const_iterator i=zauber->find(b,"Spruch");
    		i!=e;	i=zauber->find(i+1,"Spruch"))
    {  if (!((++count)&31))
       {  progressbar->set_percentage((i-b)/size);
          while(Gtk::Main::events_pending()) Gtk::Main::iteration() ;
       }
       // sinnvoller wäre es, den Tag weiterzugeben, dann brauchen wir den oben nicht zu suchen!
       list_All.push_back(new Zauber(i->getAttr("Name")));
    }
 }
#endif 
 progressbar->set_percentage(1);
}

/*
void Zauber::set_Spruchrolle(std::list<cH_MidgardBasicElement>& L,bool sp) const
{
 for(std::list<cH_MidgardBasicElement>::const_iterator i=L.begin();i!=L.end();++i)
  {
   (*i)->set_Spruchrolle(sp);
  }
}
*/