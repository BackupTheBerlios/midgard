/*  Midgard Character Generator
 *  Copyright (C) 2001 Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

// generated 2001/2/8 11:08:32 CET by thoma@ig23.
// using glademm V0.5_11c
//
// newer (non customized) versions of this file go to Fertigkeiten_auswahl.cc_new

// This file is for your program, I won't touch it again!

#include "Fertigkeiten_auswahl.hh"
#include <Aux/Transaction.h>
#include <Aux/SQLerror.h>
exec sql include sqlca;
#include "midgard_CG.hh"
#include <cstring>
#include <Gtk_OStream.h>
#include "Sprache_auswahl.hh"

Fertigkeiten_auswahl::Fertigkeiten_auswahl(midgard_CG* h,const std::string& typ,
   const std::string& typ_2,  int lernpunkte, const Grundwerte& Werte)
{
  hauptfenster=h;
  maxpunkte = lernpunkte;
  fert_auswahl_lernpunkte->set_text(itos(maxpunkte));
  // Berufsvorteile
  std::vector<string> vorteile=hauptfenster->Berufs_Vorteile();

  // Lernschema //////////////////////////////////////////////////////////////
  exec sql begin declare section;
   char db_art[100];
   int db_lernpunkte;
   char db_fertigkeiten[100]; 
   int db_erfolgswert; 
   int idb_erfolgswert; 
   char db_attribut[100];
   int idb_attribut;
   int idb_art;
   char db_pflicht[10];
   int idb_pflicht;
   int db_fp;
   char db_voraussetzung[100];
   char db_region[10];
   char query[2048];
   char db_spezies[50];
  exec sql end declare section;
  strncpy(db_spezies,(Werte.Spezies()).c_str(),sizeof(db_spezies));
  
   Transaction tr;
   // Speziesspezifische Fertigkeiten
   exec sql declare fert_spezies cursor for
      select coalesce(p.lernpunkte,0), coalesce(p.pflicht,''),
            coalesce(p.erfolgswert,0), coalesce(f.attribut,'') 
         from pflicht_lernen p, fertigkeiten f
         where typ = :db_spezies and f.fertigkeit = p.pflicht
         and p.pflicht  not in (select verboten from pflicht_lernen where
   typ=:db_spezies  and verboten is not null);
   exec sql open fert_spezies;
   SQLerror::test(__FILELINE__);
   while (true)
      {
         exec sql fetch fert_spezies into :db_lernpunkte, :db_fertigkeiten,
            :db_erfolgswert, :db_attribut ; 
         SQLerror::test(__FILELINE__,100);
         if (sqlca.sqlcode) break;
          vec_Fert.push_back(new Data_fert (db_fertigkeiten,
               db_erfolgswert,0,Werte.Spezies(),db_attribut,"*",db_lernpunkte));
         
/*         fert.push_back(db_struct_fertigkeiten(db_lernpunkte,db_fertigkeiten,
               db_erfolgswert, db_attribut,
               "*", 0, werte.spezies));
*/
      }
   exec sql close fert_spezies;

   std::string squery = " select l.fertigkeit, art, wert, f.attribut, \
             min(l.lernpunkte), pflicht_lernen.typ, \
             coalesce(f.fp,0), coalesce(v.fertigkeit,''), coalesce(f.region,'') \
      from fertigkeiten f, lernschema l, pflicht_lernen, \
         fertigkeiten_voraussetzung v \
      where ";
   if (typ_2=="") squery += " l.typ = '"+typ+"' ";
   if (typ_2!="") squery += " (l.typ = '"+typ+"' or l.typ = '"+typ_2+"') ";
   squery +=" and art = 'Fertigkeit' \
      and (f.fertigkeit = l.fertigkeit ) \
      and (f.fertigkeit = v.name ) \
      and l.typ=pflicht_lernen.typ \
      and l.fertigkeit=pflicht_lernen.pflicht \
      group by l.fertigkeit, art, wert, f.attribut, pflicht_lernen.typ, \
         f.fp, v.fertigkeit, coalesce(f.region,'')  \
      union all \
      select l.fertigkeit, art, wert, f.attribut, \
             min(l.lernpunkte), NULL, \
             coalesce(f.fp,0), coalesce(v.fertigkeit,''), coalesce(f.region,'') \
      from fertigkeiten f, lernschema l , \
         fertigkeiten_voraussetzung v \
      where ";
   if (typ_2=="") squery += " l.typ = '"+typ+"' ";
   if (typ_2!="") squery += " (l.typ = '"+typ+"' or l.typ = '"+typ_2+"') ";
   squery += "  and art = 'Fertigkeit' \
      and (f.fertigkeit = l.fertigkeit ) \
      and (f.fertigkeit = v.name ) \
      and not exists (select true from pflicht_lernen where \
            pflicht=l.fertigkeit and l.typ=pflicht_lernen.typ) \
      group by l.fertigkeit, art, wert, f.attribut, f.fp, v.fertigkeit, 
      coalesce(f.region,'')  \
      order by min,1";

   strncpy(query,squery.c_str(),sizeof(query));
   exec sql prepare sfert from :query;
   exec sql declare fertigkeiten cursor for sfert;
//   exec sql declare fertigkeiten cursor for 
/*
      select l.fertigkeit, art, wert, f.attribut,
             lernpunkte, pflicht_lernen.typ,
             f.fp, f.voraussetzung
      from fertigkeiten f, lernschema l left join pflicht_lernen 
      on l.typ=pflicht_lernen.typ
      and l.fertigkeit=pflicht_lernen.pflicht
      where l.typ = :db_typ
      and art = 'Fertigkeit' 
      and (f.fertigkeit = l.fertigkeit )//or  l.fertigkeit='KiDo-Technik') ???
      and  f.fertigkeit not in (select verboten from pflicht_lernen where 
   typ=:db_spezies  and verboten is not null) 
      order by lernpunkte, l.fertigkeit ;
*/
   exec sql open fertigkeiten;
   SQLerror::test(__FILELINE__);
   while (true)
      {
         exec sql fetch fertigkeiten into :db_fertigkeiten, :db_art:idb_art ,
            :db_erfolgswert:idb_erfolgswert, :db_attribut:idb_attribut, 
            :db_lernpunkte, :db_pflicht:idb_pflicht, :db_fp, 
            :db_voraussetzung, :db_region ; 
         SQLerror::test(__FILELINE__,100);
         if (sqlca.sqlcode) break;
//std::cout << db_fertigkeiten<<"\n";
         if (hauptfenster->region_check(db_region))
           vec_Fert.push_back(new Data_fert (db_fertigkeiten,
               idb_erfolgswert?0:db_erfolgswert,db_fp,db_voraussetzung, 
               idb_attribut?"":db_attribut,
               idb_pflicht?"":db_pflicht,db_lernpunkte));
      }
   exec sql close fertigkeiten;
  
   Gtk::OStream os(fertigkeiten_clist_auswahl);
   for(std::vector<H_Data_fert>::iterator i=vec_Fert.begin();i!=vec_Fert.end();++i)
      {
        double fac=hauptfenster->get_standard_fertigkeit(typ,typ_2,(*i)->Name());
        for (std::vector<string>::const_iterator j=vorteile.begin();
               j!=vorteile.end();++j)
           if ((*j)==(*i)->Name()) (*i)->set_Lernpunkte((*i)->Lernpunkte()-1);
        std::string pf="";
        if ((*i)->Pflicht() != "") pf = "*";
        std::string serfolgswert=itos((*i)->Erfolgswert());
        if (serfolgswert=="0") serfolgswert="";
        if ( (hauptfenster->Fertigkeiten_Voraussetzung((*i)->Name())
               || Werte.Spezies()!="Mensch") &&
            Fertigkeiten_spezies_voraussetzung((*i)->Name(),Werte.Spezies()))
         { os << (*i)->Lernpunkte()<<"\t"<<(*i)->Voraussetzung()<<"\t"<<pf<<"\t"<<(*i)->Name()<<"\t"
               << serfolgswert<<"\t"<<(*i)->Attribut()<<"\t"<<(*i)->Lernkosten()*fac<<"\n";
            os.flush(&*i);
         }
      }
   // andere Fertigkeiten ////////////////////////////////////////////////

  squery = "SELECT f.anfangswert0, coalesce(f.lp,0), f.fertigkeit, \
            f.attribut, coalesce(f.fp,0), coalesce(v.fertigkeit,''), \
      coalesce(f.region,'') \
      FROM fertigkeiten f, fertigkeiten_voraussetzung v \
      WHERE v.name = f.fertigkeit \
      AND f.fp != 0  \
      AND f.fertigkeit NOT IN \
      (SELECT fertigkeit from lernschema where ";
   if (typ_2=="") squery += " typ = '"+typ+"') ";
   if (typ_2!="") squery += " (typ = '"+typ+"' or typ = '"+typ_2+"')) ";
      squery += " ORDER BY f.fertigkeit" ; 

   strncpy(query,squery.c_str(),sizeof(query));
   exec sql prepare san_fert from :query;
   exec sql declare an_fert cursor for san_fert;
   exec sql open an_fert;
   SQLerror::test(__FILELINE__);

   while(true)
      {
         exec sql fetch an_fert into 
            :db_erfolgswert:idb_erfolgswert, :db_lernpunkte, :db_fertigkeiten, 
            :db_attribut:idb_attribut, :db_fp, :db_voraussetzung, :db_region ;
         SQLerror::test(__FILELINE__,100);
         if (sqlca.sqlcode) break;
         if (hauptfenster->region_check(db_region))
           vec_allg_Fert.push_back(new Data_fert(db_fertigkeiten,
               idb_erfolgswert?0:db_erfolgswert, db_fp, db_voraussetzung,
               idb_attribut?"":db_attribut,"",db_lernpunkte));
      }
   exec sql close an_fert;

   os <<"\n\n";   
   for(std::vector<H_Data_fert>::iterator i=vec_allg_Fert.begin();
                                                      i!=vec_allg_Fert.end();++i)
      {
        double fac=hauptfenster->get_standard_fertigkeit(typ,typ_2,(*i)->Name());
        for (std::vector<string>::const_iterator j=vorteile.begin();
               j!=vorteile.end();++j)
           if ((*j)==(*i)->Name()) (*i)->set_Lernpunkte((*i)->Lernpunkte()-1);
        std::string pf="";
        std::string serfolgswert=itos((*i)->Erfolgswert());
        if (serfolgswert=="0") serfolgswert="";
        if (hauptfenster->Fertigkeiten_Voraussetzung((*i)->Name()) &&
            Fertigkeiten_spezies_voraussetzung((*i)->Name(),Werte.Spezies()))
         { os << (*i)->Lernpunkte()<<"\t"<<(*i)->Voraussetzung()<<"\t"<<""<<"\t"<<(*i)->Name()<<"\t"
              << serfolgswert<<"\t"<<(*i)->Attribut()<<"\t"<<(*i)->Lernkosten()*fac<<"\n";
           os.flush(&*i);
         }
      }

   for (unsigned int i=0;i<fertigkeiten_clist_auswahl->columns().size();++i)
      fertigkeiten_clist_auswahl->set_column_auto_resize(i,true);

   fertigkeiten_clist_auswahl->set_selection_mode(GTK_SELECTION_MULTIPLE);
   fertigkeiten_clist_auswahl->set_reorderable(true);
}



void Fertigkeiten_auswahl::on_close_fertigkeiten_clicked()
{
   std::vector<H_Data_fert> saf;
   for (Gtk::CList::SelectionList::iterator i=fertigkeiten_clist_auswahl->selection().begin();
         i!=fertigkeiten_clist_auswahl->selection().end();++i)
     {  
      H_Data_fert *ptr = static_cast<H_Data_fert*>(i->get_data());
       saf.push_back(new Data_fert((*ptr)->Name(),(*ptr)->Erfolgswert(), (*ptr)->Attribut()));
     }
  hauptfenster->fertigkeiten_uebernehmen(saf);
  destroy();
}


void Fertigkeiten_auswahl::on_fertigkeiten_clist_auswahl_select_row(gint row, gint column, GdkEvent *event)
{
   if (maxpunkte < atoi(fertigkeiten_clist_auswahl->get_text(row,0).c_str() ))
      {
         fertigkeiten_clist_auswahl->row(row).unselect();
      }
   maxpunkte -= atoi(fertigkeiten_clist_auswahl->get_text(row,0).c_str());
   fert_auswahl_lernpunkte->set_text(itos(maxpunkte));
   // Sprache oder Schrift?
   std::string fert = fertigkeiten_clist_auswahl->get_text(row,3);
   if (fert == "Sprache" || fert == "Lesen/Schreiben" )
    {
      if (maxpunkte >=  atoi(fertigkeiten_clist_auswahl->get_text(row,0).c_str() ))
         manage (new Sprache_auswahl(hauptfenster,fert));
    }
}

void Fertigkeiten_auswahl::on_fertigkeiten_clist_auswahl_unselect_row(gint row, gint column, GdkEvent *event)
{
   maxpunkte += atoi(fertigkeiten_clist_auswahl->get_text(row,0).c_str());
   fert_auswahl_lernpunkte->set_text(itos(maxpunkte));
}

bool Fertigkeiten_auswahl::Fertigkeiten_spezies_voraussetzung(const std::string& name,const std::string& spezies)
{
  exec sql begin declare section;
   char db_spezies[50],db_verboten[50];
   char dummy[50];
  exec sql end declare section;
  strncpy(db_spezies,spezies.c_str(),sizeof(db_spezies));
  strncpy(db_verboten,name.c_str(),sizeof(db_verboten));
  exec sql select verboten into :dummy from pflicht_lernen 
      where typ = :db_spezies and verboten = :db_verboten;
  SQLerror::test(__FILELINE__,100);
  if (sqlca.sqlcode) return true;
  else return false;
  abort();
}
