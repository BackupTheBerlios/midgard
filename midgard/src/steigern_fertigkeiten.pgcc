/*  Copyright (C) 2001 Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include "midgard_CG.hh"
#include <Aux/Transaction.h>
#include <Aux/SQLerror.h>
exec sql include sqlca;
#include <cstring>
//#include <Gtk_OStream.h>
//#include <algorithm>
#include "WindowInfo.hh"
//#include <Aux/EntryValueIntString.h>
//#include <Aux/EntryValueEmptyInt.h>
#include "class_Ausnahmen.hh"
#include "class_fertigkeiten.hh"

void midgard_CG::on_fertigkeiten_laden_clicked()
{
  list_Fertigkeiten_neu.clear();
  exec sql begin declare section;
   char db_name[100], query[1024];
  exec sql end declare section;
  std::string squery = "SELECT fertigkeit \
   FROM fertigkeiten WHERE \
   fertigkeit NOT IN (SELECT fertigkeit FROM charaktere_fertigkeiten \
   WHERE charakter_name = '"+Werte.Name_Charakter()+"' \
   AND version = '"+Werte.Version()+"') \
   AND fertigkeit != 'Sprache' AND fertigkeit != 'Lesen/Schreiben' \
   AND fertigkeit  not in (select coalesce(verboten,'') from pflicht_lernen where \
    typ='"+Werte.Spezies()+"'  and spielbegin is null) \
   AND fp is not null
   ORDER BY fertigkeit";

 strncpy(query,squery.c_str(),sizeof(query));

 Transaction tr;  
 exec sql prepare fert_ein_ from :query ;  
 exec sql declare fert_ein cursor for fert_ein_ ;  
 exec sql open fert_ein;
 SQLerror::test(__FILELINE__);
 int count=0;
 laden_label->show();
 while (true)
   {
      exec sql fetch fert_ein into :db_name; 
      SQLerror::test(__FILELINE__,100);  
      if (sqlca.sqlcode) break;
      laden_label->set_text(itos(++count)+" Fertigkeiten geladen");
      while(Gtk::Main::events_pending()) Gtk::Main::iteration() ;

//      std::string s1 = db_standard, s2 = db_standard2;
//      Ausnahmen ausnahmen(Werte,Typ,vec_Beruf);
//      s1 = ausnahmen.Ausnahmen_string(db_fertigkeiten,db_standard,"");
//std::cout << "\t\t"<<s1<<"\t"<<fac<<"\n";
//      <<"\t->"<<db_region<<"<-\t"<<BRbool<<"\t"<<region_check(db_region)<<"\n";
      cH_Fertigkeit fertigkeit(db_name,Typ,Ausnahmen(Werte,Typ,vec_Beruf));
      if (Fertigkeiten_Voraussetzung(fertigkeit->Name()) 
            && region_check(fertigkeit->Region()) 
)//            && (s1!="" || s2!="") )
       {
         list_Fertigkeiten_neu.push_back(fertigkeit);
       }
   }
 laden_label->hide();
 exec sql close fert_ein;
 tr.commit();
 fertigkeiten_zeigen();
}

void midgard_CG::fertigkeiten_zeigen()
{
 zeige_werte(Werte);
 on_speichern_clicked();
 show_alte_fertigkeiten();
 show_neue_fertigkeiten();
}


void midgard_CG::on_leaf_selected_alte_fert(cH_RowDataBase d)
{  
 const Data_fert *dt=dynamic_cast<const Data_fert*>(&*d);

 if (dt->Name()=="KiDo" && kido_steigern_check(dt->Erfolgswert())) return;
 if (radio_fert_steigern->get_active() && dt->Steigern())
    {
      // Steigern mit lernen
      if (!togglebutton_praxispunkte_fertigkeiten->get_active()) 
         {
            if (!steigern(dt->Steigern(),dt->Name())) return;
            Werte.add_GFP(dt->Steigern());
            for (std::list<cH_Fertigkeit>::iterator i=list_Fertigkeiten.begin();
                     i!= list_Fertigkeiten.end();++i )
               if ( (*i)->Name() == dt->Name()) (*i)->set_Erfolgswert(1+(*i)->Erfolgswert()); 
         }
      else  // Lernen mit Praxispunkten 
         {
            bool wuerfeln;
            if (radiobutton_praxis_wuerfeln_fertigkeiten->get_active()) wuerfeln = true;
            if (radiobutton_praxis_auto_fertigkeiten->get_active()) wuerfeln = false;
            int gelungen = praxispunkte_wuerfeln(dt->Name(),dt->Erfolgswert(),"Fertigkeit",wuerfeln);
            if (gelungen)
               {
                  Werte.add_GFP(dt->Steigern()/2);
                  for (std::list<cH_Fertigkeit>::iterator i=list_Fertigkeiten.begin();
                        i!= list_Fertigkeiten.end();++i )
                     if ( (*i)->Name() == dt->Name()) (*i)->set_Erfolgswert(1+(*i)->Erfolgswert()); 
               }
         }     
    }
   if (radio_fert_reduzieren->get_active() && dt->Reduzieren())
         {
            if (steigern_bool) desteigern(dt->Reduzieren());
            Werte.add_GFP(-dt->Reduzieren());
            for (std::list<cH_Fertigkeit>::iterator i=list_Fertigkeiten.begin();
                     i!= list_Fertigkeiten.end();++i )
               if ( (*i)->Name() == dt->Name()) (*i)->set_Erfolgswert((*i)->Erfolgswert()-1); 
         }
   if (radio_fert_verlernen->get_active() && dt->Verlernen())
         {
            if (steigern_bool) desteigern(dt->Verlernen());
            Werte.add_GFP(-dt->Verlernen());
            move_fertigkeiten(list_Fertigkeiten,list_Fertigkeiten_neu,dt->Name());
         }
   fertigkeiten_zeigen();
}

void midgard_CG::get_srv_kosten(const cH_Fertigkeit& fertigkeit, int &steigern,int &reduzieren,int &verlernen) const
{
  exec sql begin declare section;
    int db_steigern=0, db_reduzieren=0, db_verlernen;
    char query[1024];
    char db_standard[5],db_standard2[5];
  exec sql end declare section;
  std::string squery;

  if (fertigkeit->Erfolgswert() != 0) // Fertigkeiten MIT Erfolgswert
     {
       squery = "SELECT coalesce(p"+itos(abs(fertigkeit->Erfolgswert()))
          +",0),coalesce(p"+itos(abs(fertigkeit->Erfolgswert()+1))+",0),fp,f."+Typ[0]->Short();
       if (Typ[1]->Short()!="") squery += ", "+Typ[1]->Short();
       squery +=" FROM steigern_fertigkeiten s, steigern_fertigkeiten_werte w, \
          fertigkeiten f WHERE s.name = '"+fertigkeit->Name()+"' AND w.name = s.wie \
             AND f.fertigkeit = '"+fertigkeit->Name()+"'";
     }
  else // Fertigkeiten OHNE Erfolgswert
     {
       squery = "SELECT fp,f."+Typ[0]->Short();
       if (Typ[1]->Short()!="") squery += ", "+Typ[1]->Short();
       squery  +=" FROM steigern_fertigkeiten s, fertigkeiten f \
          WHERE s.name = '"+fertigkeit->Name()+"' \
            AND f.fertigkeit = '"+fertigkeit->Name()+"'";
     }
  strncpy(query,squery.c_str(),sizeof(query));

  Transaction tr;
  exec sql prepare kosten_ein_ from :query ;  
  exec sql declare kosten_ein cursor for kosten_ein_ ;  
  exec sql open kosten_ein;
  if(Typ[1]->Short()!="")      
    {
      if (fertigkeit->Erfolgswert() != 0) // Fertigkeiten MIT Erfolgswert
         exec sql fetch kosten_ein into :db_reduzieren, 
             :db_steigern, :db_verlernen, :db_standard,:db_standard2;
      else // Fertigkeiten OHNE Erfolgswert
          exec sql fetch kosten_ein into :db_verlernen, :db_standard,:db_standard2;
    }
  else
    {
      if (fertigkeit->Erfolgswert() != 0) // Fertigkeiten MIT Erfolgswert
         exec sql fetch kosten_ein into :db_reduzieren, 
            :db_steigern, :db_verlernen, :db_standard;
      else // Fertigkeiten OHNE Erfolgswert
          exec sql fetch kosten_ein into :db_verlernen, :db_standard;
    }
  SQLerror::test(__FILELINE__);
  exec sql close kosten_ein;
  tr.close();

//  double fac = midgard_CG::get_standard_fertigkeit_(db_standard,db_standard2,name);
  double fac = fertigkeit->Standard_Faktor();
  steigern = (int)(db_steigern * fac);
  reduzieren=(int)(db_reduzieren * fac);
  if (db_reduzieren !=0) verlernen = 0 ;
  else  verlernen=(int)(db_verlernen *fac);
}

void midgard_CG::show_alte_fertigkeiten()
{
   std::vector<cH_RowDataBase> datavec;
   for ( std::list<cH_Fertigkeit>::const_iterator i=list_Fertigkeiten.begin();i!=list_Fertigkeiten.end();++i)
    {
      int steigern, reduzieren, verlernen;
      get_srv_kosten(*i,steigern,reduzieren,verlernen);
      datavec.push_back(new Data_fert((*i)->Name(),(*i)->Erfolgswert(),steigern,reduzieren,verlernen));
    }
 alte_fert_tree->setDataVec(datavec);  
}

void midgard_CG::on_button_fertigkeiten_sort_clicked()
{
  std::deque<guint> seq = alte_fert_tree->get_seq();
  switch((Data_fert::Spalten_A)seq[0]) {
      case Data_fert::NAMEa : list_Fertigkeiten.sort(Fertigkeiten_sort_name()); ;break;
      case Data_fert::WERTa : list_Fertigkeiten.sort(Fertigkeiten_sort_wert()); ;break;
      default : manage(new WindowInfo("Sortieren nach diesem Parameter\n ist nicht möglich"));
   }
}



void midgard_CG::show_neue_fertigkeiten()
{
 std::vector<cH_RowDataBase> datavec;
 for(std::list<cH_Fertigkeit>::const_iterator i=list_Fertigkeiten_neu.begin();i!=list_Fertigkeiten_neu.end();++i)
  {
   (*i)->set_Erfolgswert((*i)->Anfangswert());   
   datavec.push_back(new Data_fert((*i)->Name(),(*i)->Anfangswert(),
               (*i)->Kosten(),(*i)->Standard__(),(*i)->Voraussetzung()));
  }
 neue_fert_tree->setDataVec(datavec);
}

bool midgard_CG::kido_steigern_check(int wert)
{
  if (Werte.Grad()+10 > wert) return false;
  else
   { std::string strinfo ="KiDo darf nur auf maximal Grad+10 gesteigert werden.\n";
     manage (new WindowInfo(strinfo));
     return true;
   }
}



void midgard_CG::move_fertigkeiten(std::list<cH_Fertigkeit>& von,std::list<cH_Fertigkeit>& nach,const std::string& name)
{
 for (std::list<cH_Fertigkeit>::iterator i=von.begin();i!= von.end();++i)
     if ((*i)->Name()==name) 
       {nach.splice(nach.begin(),von,i);break;}
  fertigkeiten_zeigen();
}


void midgard_CG::on_leaf_selected_neue_fert(cH_RowDataBase d)
{  const Data_fert *dt=dynamic_cast<const Data_fert*>(&*d);
  if (!steigern(dt->Lernkosten(),dt->Name())) return;
  Werte.add_GFP(dt->Lernkosten());
  move_fertigkeiten(list_Fertigkeiten_neu,list_Fertigkeiten,dt->Name());

  if (dt->Name()=="KiDo") {kido_bool=true;show_gtk();
      std::string strinfo="Jetzt muß ein Stil unter 'Lernschema' -> 'KiDo' gewählt werden !!!";
      manage (new WindowInfo(strinfo,true)); }
  if (dt->Name()=="Wissen von der Magie") 
      {  doppelcharaktere();
         std::string strinfo ="Jetzt unter 'Grundwerte' die zweite Charkakterklasse wählen\n";
         strinfo += " und anschließend 'Fertigkeiten neu laden' klicken\n";
         manage (new WindowInfo(strinfo,true));
         // Resistenzboni für Zauberer setzten:
         Werte.set_magBoni(Werte.bo_Psy()+3,Werte.bo_Phs()+1,Werte.bo_Phk()+3);
         if (Werte.Zaubern_wert()==0) Werte.set_Zaubern_wert(10);
      }
}

void midgard_CG::on_radio_fert_steigern_toggled()
{
}



void midgard_CG::on_radio_fert_reduzieren_toggled()
{
   if (radio_fert_reduzieren->get_active())
      togglebutton_praxispunkte_fertigkeiten->set_active(false);
}

void midgard_CG::on_radio_fert_verlernen_toggled()
{
   if (radio_fert_verlernen->get_active())
      togglebutton_praxispunkte_fertigkeiten->set_active(false);
}

void midgard_CG::on_togglebutton_praxispunkte_fertigkeiten_toggled()
{
    if (togglebutton_praxispunkte_fertigkeiten->get_active())
      radio_fert_steigern->set_active(true);

}

void midgard_CG::on_radiobutton_praxis_wuerfeln_fertigkeiten_toggled()
{
}

void midgard_CG::on_radiobutton_praxis_auto_fertigkeiten_toggled()
{
}

bool midgard_CG::Fertigkeiten_Voraussetzung(const std::string& fertigkeit)
{
  exec sql begin declare section;
   int db_st,db_ge,db_ko,db_in,db_zt,db_pa,db_au,db_sb,db_rw;
   char db_fertigkeit[30], db_fert[30];
  exec sql end declare section;
  strncpy(db_fertigkeit,fertigkeit.c_str(),sizeof(db_fertigkeit));

  exec sql select distinct coalesce(st,'0'), coalesce(ge,'0'),
   coalesce(ko,'0'),  coalesce("in",'0'), coalesce(zt,'0'),
   coalesce(au,'0'), coalesce(pa,'0'), 
   coalesce(sb,'0'), coalesce(rw,'0'), coalesce(fertigkeit,'')
   into :db_st,:db_ge,:db_ko,:db_in,:db_zt,:db_au,:db_pa,
         :db_sb,:db_rw,:db_fert
   from fertigkeiten_voraussetzung where name= :db_fertigkeit;
  SQLerror::test(__FILELINE__,100);
  if (sqlca.sqlcode) return true;
//  SQLerror::test(__FILELINE__);
    if ( db_st<=Werte.St() &&
         db_ge<=Werte.Ge() &&
         db_ko<=Werte.Ko() &&
         db_in<=Werte.In() &&
         db_zt<=Werte.Zt() &&
         db_au<=Werte.Au() &&
         db_pa<=Werte.pA() &&
         db_sb<=Werte.Sb() &&
         db_rw<=Werte.RW()
       )   
     return true;
  else return false ;
}
