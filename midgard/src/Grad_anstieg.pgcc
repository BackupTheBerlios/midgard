/*  Midgard Character Generator
 *  Copyright (C) 2001-2002 Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include "Grad_anstieg.hh"
#ifndef USE_XML
#include <Aux/SQLerror.h>
#include <Aux/Transaction.h>
exec sql include sqlca;
#else
#include "xml.h"
#endif
#include <gtk--/main.h>

Grad_anstieg::Grad_anstieg(Gtk::ProgressBar *progressbar)
: steigern_EP_prozent(50), grad_basiswerte(1)
{
#ifndef USE_XML
 exec sql begin declare section;
   int db_a,db_r,db_z,db_ak,db_rk,db_zk;
   int db_grad,db_gfp,db_schicksal;
   int db_size;
 exec sql end declare section;
 exec sql select count (grad) into :db_size from grad_anstieg; 
 SQLerror::test(__FILELINE__);
 exec sql declare GREIN cursor for select grad,gfp,schicksalsgunst,
   coalesce(abwehr,0),coalesce(abwehr_kosten,0),coalesce(resistenz,0),
   coalesce(resistenz_kosten,0),coalesce(zaubern,0),coalesce(zaubern_kosten,0)
   from grad_anstieg order by grad;
 Transaction tr;
 exec sql open GREIN;
 SQLerror::test(__FILELINE__);
 double count=0;  
 while(true)
  {
   progressbar->set_percentage(count/db_size);
   while(Gtk::Main::events_pending()) Gtk::Main::iteration() ;
   exec sql fetch GREIN into :db_grad,:db_gfp,:db_schicksal,
      :db_a,:db_ak,:db_r,:db_rk,:db_z,:db_zk;
   SQLerror::test(__FILELINE__,100);
   if (sqlca.sqlcode) break;
   map_grad[db_grad] = st_grad(db_a,db_ak,db_r,db_rk,db_z,db_zk,db_gfp,db_schicksal);
   ++count;
  }
#else
 const Tag *Gradanstieg=xml_data->find("Gradanstieg");
 if (Gradanstieg)
 {  Tag::const_iterator b=Gradanstieg->begin(),e=Gradanstieg->end();
    double size=e-b;
    FOR_EACH_CONST_TAG_OF_5(i,*Gradanstieg,b,e,"Grad")
    {  progressbar->set_percentage((i-b)/size);
       while(Gtk::Main::events_pending()) Gtk::Main::iteration() ;
       const Tag *Kosten=i->find("Kosten");
       map_grad[i->getIntAttr("Grad")]=
       	st_grad(i->getIntAttr("Abwehr"),Kosten->getIntAttr("Abwehr"),
       		i->getIntAttr("Resistenz"),Kosten->getIntAttr("Resistenz"),
       		i->getIntAttr("Zaubern"),Kosten->getIntAttr("Zaubern"),
       		i->getIntAttr("GFP"), i->getIntAttr("Schicksalsgunst"));
    }
 }
#endif  
 progressbar->set_percentage(1);
}

int Grad_anstieg::get_Abwehr(int grad)  
{
  int x=0; 
  while(x==0)   x = map_grad[grad--].abwehr;
  return x;
}
int Grad_anstieg::get_Abwehr_Kosten(int grad)  
{
  int x=0; 
  while(x==0)   x = map_grad[grad--].abwehr_kosten;
  return x;
}
int Grad_anstieg::get_Zauber(int grad)  
{
  int x=0; 
  while(x==0)   x = map_grad[grad--].zaubern;
  return x;
}
int Grad_anstieg::get_Zauber_Kosten(int grad)  
{
  int x=0; 
  while(x==0)   x = map_grad[grad--].zaubern_kosten;
  return x;
}
int Grad_anstieg::get_Resistenz(int grad)  
{
  int x=0; 
  while(x==0)   x = map_grad[grad--].resistenz;
  return x;
}
int Grad_anstieg::get_Resistenz_Kosten(int grad)   
{
  int x=0; 
  while(x==0)   x = map_grad[grad--].resistenz_kosten;
  return x;
}
int Grad_anstieg::get_Schicksalsgunst(int grad)   
{
  return map_grad[grad].schicksalsgunst;
}

int Grad_anstieg::get_Grad(int gfp) 
{
 map<int,st_grad>::const_reverse_iterator e=map_grad.rend();
 for(map<int,st_grad>::const_reverse_iterator i=map_grad.rbegin();i!=e;++i)
{ 
//cout<<gfp<<'\t'<< i->second.gfp<<'\t'<<i->first<<'\n';
   if( i->second.gfp <= gfp) 
      return i->first;
}
 assert(0);
}
