/*  Midgard Character Generator
 *  Copyright (C) 2001-2002 Malte Thoma
 *  Copyright (C) 2002      Christof Petig 
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include "Waffe.hh"
#include "midgard_CG.hh"
#ifndef USE_XML
#include <Aux/SQLerror.h>
#include <Aux/Transaction.h>
exec sql include sqlca;
#endif
#include "Typen.hh"
#include <gtk--/main.h>
#include <Aux/itos.h>

cH_Waffe::cache_t cH_Waffe::cache;

cH_Waffe::cH_Waffe(const std::string& name IF_XML(, bool create))
{
 cH_Waffe *cached(cache.lookup(name));
 if (cached) *this=*cached;
 else
#ifndef USE_XML 
  {
   *this=cH_Waffe(new Waffe(name));  
   cache.Register(name,*this);
  }
#else
  cerr << "Waffe '" << name << "' nicht im Cache\n";
  if (create)
  {  static Tag t2("Waffe"); 
     // note that this Tag is shared ... works well for now
     t2.setAttr("Name",name);
     *this=cH_Waffe(&t2);
  }
  else throw NotFound();
//  assert(!"Waffe im Cache");
#endif
}

#ifdef USE_XML
cH_Waffe::cH_Waffe(const Tag *tag)
{*this=cH_Waffe(new Waffe(tag));
 cache.Register(tag->getAttr("Name"),*this);
}
#endif

void Waffe::get_Waffe()
{
#ifndef USE_XML
  exec sql begin declare section;
   int db_schwierigkeit,db_schaden_b, db_st,db_gw,db_gs,
      db_reichweite_0,db_reichweite_n,db_reichweite_m,
      db_reichweite_f,db_lern_l,db_lern_s;
   char query[1024],db_grundkenntnisse[50],db_art[50],db_art2,
      db_region[10],db_schaden[30],db_waffenrang[10],
      db_wm_abwehr_leicht[10], db_wm_abwehr_schwer[10], db_voraussetzung[50];
  exec sql end declare section; 
  std::string squery ="select grundkenntnisse,schwierigkeit,art,coalesce(art_2,''),
      coalesce(schaden,''),coalesce(schaden_b,''),
      coalesce(waffenrang,''),coalesce(wm_abwehr_leicht,''),
      coalesce(wm_abwehr_schwer,''),coalesce(st,0),coalesce(gw,0),coalesce(gs,0),
      coalesce(zusatz,''),
      coalesce(region,''),coalesce(reichweite_0,-1),
      coalesce(reichweite_n,-1),coalesce(reichweite_m,-1),
      coalesce(reichweite_f,-1),coalesce(lern_land,99),coalesce(lern_stadt,99)
      from waffen
      where name = '"+Name()+"'";
//      where name = '"+get_waffe_from_alias(Name())+"'";
  strncpy(query,squery.c_str(),sizeof(query));
  Transaction tr;
  exec sql prepare cl_waffen_ein_ from :query ;
  exec sql declare cl_waffen_ein cursor for cl_waffen_ein_ ;

//cout << query<<'\n';
  exec sql open cl_waffen_ein;
  SQLerror::test(__FILELINE__);
  exec sql fetch cl_waffen_ein into 
   :db_grundkenntnisse,:db_schwierigkeit,:db_art,:db_art2,:db_schaden,
   :db_schaden_b,:db_waffenrang,:db_wm_abwehr_leicht,:db_wm_abwehr_schwer,
   :db_st,:db_gw,:db_gs,:db_voraussetzung,:db_region,:db_reichweite_0,:db_reichweite_n,
   :db_reichweite_m,:db_reichweite_f,:db_lern_l,:db_lern_s;
  SQLerror::test(__FILELINE__);
   grundkenntnisse=db_grundkenntnisse;
   schwierigkeit=db_schwierigkeit;
   art=db_art;
//cout << "Waffe, art = "<<db_art<<' '<<art<<' '<<Art()<<'\n';
   art2=db_art2;
   schaden=db_schaden;
   schaden_bonus=db_schaden_b;
   waffenrang=db_waffenrang;
   wm_abwehr_leicht=db_wm_abwehr_leicht;
   wm_abwehr_schwer=db_wm_abwehr_schwer;
   st=db_st; gw=db_gw; gs=db_gs;
   voraussetzung=db_voraussetzung;
   region=db_region;
   reichweite_0=db_reichweite_0;reichweite_n=db_reichweite_n;
   reichweite_m=db_reichweite_m;reichweite_f=db_reichweite_f;
   lern_land=db_lern_l; lern_stadt=db_lern_s;

  exec sql close cl_waffen_ein;
  tr.close();
#else
   assert(tag);
   grundkenntnisse=tag->getAttr("Grundkenntnisse");
   schwierigkeit=tag->getIntAttr("Schwierigkeit");
   art=tag->getAttr("Kategorie");
   art2=tag->getAttr("Klasse");
   schaden=tag->getAttr("Schaden");
   schaden_bonus=tag->getIntAttr("Schadensbonus");
   voraussetzung=tag->getAttr("erfordert");
   region=tag->getAttr("Region");
   
   const Tag *Modifikationen=tag->find("Modifikationen");
   if (Modifikationen)
   {  waffenrang=Modifikationen->getAttr("Waffenrang");
      wm_abwehr_leicht=Modifikationen->getAttr("Abwehr-leicht");
      wm_abwehr_schwer=Modifikationen->getAttr("Abwehr-schwer");
   }

   const Tag *Voraussetzungen=tag->find("Voraussetzungen");
   if (Voraussetzungen)
   {  st=Voraussetzungen->getIntAttr("St");
      gw=Voraussetzungen->getIntAttr("Gw");
      gs=Voraussetzungen->getIntAttr("Gs");
   }

   const Tag *Reichweite=tag->find("Reichweite");
   if (Reichweite)
   {  reichweite_0=Reichweite->getIntAttr("null");
      reichweite_n=Reichweite->getIntAttr("nah");
      reichweite_m=Reichweite->getIntAttr("mittel");
      reichweite_f=Reichweite->getIntAttr("fern");
   }

   const Tag *Lernkosten=tag->find("Lernkosten");
   if (Lernkosten)
   {  lern_land=Lernkosten->getIntAttr("Land");
      lern_stadt=Lernkosten->getIntAttr("Stadt");
   }
#endif

   if(Art()=="Verteidigung") erfolgswert=1;
   else erfolgswert=4;   
}

void Waffe::get_Alias() 
{
#ifndef USE_XML
  exec sql begin declare section;
   char query[1024], db_alias[50], db_region[10], db_schaden[30];
   int db_schaden_b,db_angriffs_mod;
  exec sql end declare section; 
  std::string squery ="select alias,
      coalesce(r.schaden,w.schaden,''),coalesce(r.schaden_b,w.schaden_b,0),
      coalesce(angriffs_mod,''),r.region
      from waffen_region_name r,waffen w where r.name=w.name
      and r.name = '"+Name()+"'";
  strncpy(query,squery.c_str(),sizeof(query));
  Transaction tr;
  exec sql prepare cl_walias_ein_ from :query ;
  exec sql declare cl_walias_ein cursor for cl_walias_ein_ ;

//cout << query<<'\n';
  exec sql open cl_walias_ein;
  SQLerror::test(__FILELINE__);
  while (true)
   {
     exec sql fetch cl_walias_ein into 
      :db_alias,:db_schaden,:db_schaden_b,:db_angriffs_mod,:db_region;
     SQLerror::test(__FILELINE__,100);
     if (sqlca.sqlcode) break;
     list_alias.push_back(st_alias( db_alias,db_region,db_schaden,db_schaden_b,db_angriffs_mod));
   }
  exec sql close cl_waffen_ein;
  tr.close();
//
//for (list<Waffe::st_alias>::const_iterator j=list_alias.begin();j!=list_alias.end();++j)
//cout << Name()<<'\t'<<(*j).name<<'\t'<<(*j).region<<'\n';
#else
    assert(tag);
    FOR_EACH_CONST_TAG_OF(i,*tag,"regionaleVariante")
    {  int Angriff=0;
       const Tag *Modifikationen=i->find("Modifikationen");
       if (Modifikationen) Angriff=Modifikationen->getIntAttr("Angriff");
       list_alias.push_back(st_alias(i->getAttr("Name"),i->getAttr("Region"),
       		i->getAttr("Schaden"),i->getIntAttr("Schadensbonus"),Angriff));
    }
#endif
}


bool Waffe::Grundkenntnis_vorhanden(const std::list<cH_MidgardBasicElement>& list_WaffenGrund) const
{
 for (std::list<cH_MidgardBasicElement>::const_iterator i=list_WaffenGrund.begin();i!=list_WaffenGrund.end();++i)
   if (Grundkenntnis()==(*i)->Name()) return true;
 return false;
}


bool Waffe::SG_Voraussetzung(const Grundwerte& Werte) const
{
  if ( St()<=Werte.St() && Gw()<=Werte.Gw() && Gs()<=Werte.Gs() ) return true;
  else return false ;
}



std::string WaffeBesitz::Schaden(const Grundwerte& Werte,const std::string& name) const
{
  if (waffe->Art()=="Verteidigung") return "-"+itos(waffe->Schaden_Bonus(name))+"AP";
  std::string s=waffe->Schaden(name);
  int sb=waffe->Schaden_Bonus(name) + sl_Bonus();
//cout << "WAFFE = "<<waffe->Name()<<'\t'<<waffe->Erfolgswert()<<'\n';
  if (Name()=="waffenloser Kampf" || Name()=="Faustkampf" ) 
      { s="W6";
        int w = waffe->Erfolgswert();
//cout << "Erfolgswert WAFFENLOS = "<<itos(w)<<'\n';
        if (         w <= 7) sb=-4;
        if ( 8<=w && w <=11) sb=-3;
        if (12<=w && w <=15) sb=-2;
        if (16<=w)           sb=-1;
      }
  if (waffe->Art()!="Fern") sb += Werte.bo_Sc();
  if     (sb == 0) return s;
  else if(sb  > 0) return s+"+"+itos(sb);
  else if(sb  < 0) return s+"-"+itos(sb);
  abort(); //Never get here
}

std::string WaffeBesitz::Bonus() const 
{ 
  if (Magisch()=="" && av_Bonus()==0 && sl_Bonus()==0 ) return "";
  return "("+itos(av_Bonus())+"/"+itos(sl_Bonus())+")";
}



std::string Waffe::Reichweite() const
{  
   if(reichweite_0==-1) return "";
   return itos(reichweite_0)+"/"+itos(reichweite_n)+"/"+
               itos(reichweite_m)+"/"+itos(reichweite_f);
}

std::string Waffe::WM_Abwehr() const
{
  std::string s1=wm_abwehr_leicht, s2 = wm_abwehr_schwer;
  if (s1=="" && s2=="") return "";
  if (s1=="") s1="0";
  if (s2=="") s2="0";
  return s1+"$|$"+s2;
}


int Waffe::WM_Angriff(const std::string& name) const 
{
  if(Name()==name) return 0;
  for(list<st_alias>::const_iterator i=list_alias.begin();i!=list_alias.end();++i)
    if (name==(*i).name) return (*i).angriffs_mod;
  assert(false);
}

std::string Waffe::Schaden(const std::string& name) const 
{
  if(Name()==name) return schaden;
  for(list<st_alias>::const_iterator i=list_alias.begin();i!=list_alias.end();++i)
    if (name==(*i).name) return (*i).schaden;
  assert(false);
}

int Waffe::Schaden_Bonus(const std::string& name) const 
{
  if(Name()==name) return schaden_bonus;
  for(list<st_alias>::const_iterator i=list_alias.begin();i!=list_alias.end();++i)
    if (name==(*i).name) return (*i).schaden_bonus;
  assert(false);
}

std::string Waffe::Region(const std::string& name) const
{
  if(Name()==name) return region;
  for(list<st_alias>::const_iterator i=list_alias.begin();i!=list_alias.end();++i)
   if (name==(*i).name) return (*i).region;
  assert(false);
}


map<std::string,std::string> Waffe::fill_map_alias_waffe(Gtk::ProgressBar *progressbar)
{
  map<std::string,std::string> M;

#ifndef USE_XML
  exec sql begin declare section;
   char db_alias[50];
   char db_name[50];
   int db_size;
  exec sql end declare section;
  exec sql select count(name) into :db_size from waffen_region_name;  
  exec sql declare WAliasC cursor for select name,alias from
      waffen_region_name;
  Transaction tr;  
  exec sql open WAliasC;
  double count=0;
  while (true)
   {
     progressbar->set_percentage(count/db_size);
     while(Gtk::Main::events_pending()) Gtk::Main::iteration() ;
     exec sql fetch WAliasC into :db_name,:db_alias;
     SQLerror::test(__FILELINE__,100);
     if (sqlca.sqlcode) break;     
     M[db_alias]=db_name;
     ++count;
   }
  tr.close();
  exec sql close WAliasC;
#else  
 const Tag *waffen=xml_data->find("Waffen");
 if (!waffen)
    cerr << "<Waffen><Waffe/>... nicht gefunden\n";
 else
 {  Tag::const_iterator b=waffen->begin(),e=waffen->end();
    double size=e-b;
    FOR_EACH_CONST_TAG_OF_5(i,*waffen,b,e,"Waffe")
    {  progressbar->set_percentage((i-b)/size);
       while(Gtk::Main::events_pending()) Gtk::Main::iteration() ;
       
       FOR_EACH_CONST_TAG_OF(j,*i,"regionaleVariante")
          M[j->getAttr("Name")]=i->getAttr("Name");
    }
 }
#endif  
  progressbar->set_percentage(1);
  return M;
}


int Waffe::MaxErfolgswert(const Grundwerte& w,const vector<cH_Typen>& Typ) const
{
 assert(Typ.size()==2);
 int maxwert=0;
 if (art == "Verteidigung")
  {
     maxwert = 7;
     if ((Typ[0]->Short() == "Kr" || Typ[0]->Short() == "Sö") && Typ[1]->Short()=="") maxwert = 8;
     else if (Typ[0]->Zaubern() == "z" ) maxwert = 6;
  }
 else
  {
    maxwert = 17;
    if ((Typ[0]->Short() == "Kr" || Typ[0]->Short() == "Sö") && Typ[1]->Short()=="") maxwert = 19;
    if (Typ[0]->Zaubern() == "z" ) maxwert = 14;
  }
 return maxwert;
}


std::string Waffe::get_Verteidigungswaffe(int ohne_waffe,
   const std::list<cH_MidgardBasicElement>& list_Waffen,
   const std::list<cH_MidgardBasicElement>& list_Waffen_besitz,
   const vector<cH_Typen>& Typ,
   const Grundwerte& Werte)
{
   std::list<cH_MidgardBasicElement> Verteidigungswaffen;
   Verteidigungswaffen.push_back(new WaffeBesitz(
      cH_Waffe("waffenloser Kampf"),"waffenloser Kampf","",0,0,""));
   for (std::list<cH_MidgardBasicElement>::const_iterator i=list_Waffen_besitz.begin();
         i!=list_Waffen_besitz.end();++i)
     {
       cH_WaffeBesitz WB(*i);
       if (WB->Waffe()->Art()=="Verteidigung" || WB->Waffe()->Name()=="Kampfstab" || WB->Name()=="Sai" ||
          WB->Name()=="Tonfa" || WB->Name()=="GunSen" || WB->Name()=="BuKasa" || 
          WB->Name()=="KusariGama" || WB->Name()=="TetsuBo" ) 
         Verteidigungswaffen.push_back(*i);
     }
   std::string Vwaffewert;
   for(std::list<cH_MidgardBasicElement>::const_iterator i=Verteidigungswaffen.begin();
         i!=Verteidigungswaffen.end();/*siehe unten*/)
     {
      cH_WaffeBesitz WB(*i);
      std::vector<int> vwert;
      for (std::list<cH_MidgardBasicElement>::const_iterator j=list_Waffen.begin();j!=list_Waffen.end();++j)      
         { cH_Waffe w(*j);
            if (WB->Name() == w->Name()) 
               { 
                 int erf_wert;
                 if (WB->Name()=="Kampfstab"||WB->Name()=="Sai"||WB->Name()=="Tonfa"||WB->Name()=="KusariGama") 
                  {erf_wert = w->Erfolgswert()-5; (erf_wert<=7)?:erf_wert=7; }
                 else if (WB->Name()=="TetsuBo")
                  {erf_wert = w->Erfolgswert()-7; (erf_wert<=7)?:erf_wert=7; }
                 else if (WB->Name()=="GunSen"||WB->Name()=="BuKasa")
                  {erf_wert = w->Erfolgswert(); (erf_wert<=10)?:erf_wert=10; }
                 else if (WB->Name()=="waffenloser Kampf")
                  {if ( w->Erfolgswert()<8)              break       ;
                   if ( 8<=w->Erfolgswert()&&w->Erfolgswert()<12) erf_wert = 1;
                   if (12<=w->Erfolgswert()&&w->Erfolgswert()<16) erf_wert = 2;
                   if (16<=w->Erfolgswert())                      erf_wert = 3;
                  }
                 else erf_wert = w->Erfolgswert();
                 int ewert = Werte.Abwehr_wert()+Werte.bo_Ab() // Grundwerte
                           + erf_wert + WB->av_Bonus() ;// Waffenwerte
                 Vwaffewert += itos(ewert);
               }
         }
       ++i;
       if (i!=Verteidigungswaffen.end() && Vwaffewert!="") Vwaffewert += "$|$"; 
     }
   return Vwaffewert;
}

Waffe_All::Waffe_All(Gtk::ProgressBar *progressbar)
{
#ifndef USE_XML
 exec sql begin declare section;
   char db_name[50][100];
   int db_size;
 exec sql end declare section;
 exec sql select count(name) into :db_size from waffen;
 exec sql declare WAein cursor for select distinct name from waffen;
 Transaction tr;

 exec sql open WAein;
 SQLerror::test(__FILELINE__);  
 double count=0;
 while(true)   
  {
   exec sql fetch 50 in WAein into :db_name;
   SQLerror::test(__FILELINE__,100);
//   if (sqlca.sqlcode) break;
   int j=sqlca.sqlerrd[2];
   for (int i=0;i<j;++i)
    {
      progressbar->set_percentage(count/db_size);
      while(Gtk::Main::events_pending()) Gtk::Main::iteration() ;
//      list_All.push_back(new Waffe(db_name[i]));
      list_All.push_back(&*(cH_Waffe(db_name[i])));
      ++count;
     }
   if(j<50) break;
  }
 exec sql close WAein;
 tr.close();
#else
 const Tag *waffen=xml_data->find("Waffen");
 if (!waffen)
    cerr << "<Waffen><Waffe/>... nicht gefunden\n";
 else
 {  Tag::const_iterator b=waffen->begin(),e=waffen->end();
    double size=e-b;
    FOR_EACH_CONST_TAG_OF_5(i,*waffen,b,e,"Waffe")
    {  progressbar->set_percentage((i-b)/size);
       while(Gtk::Main::events_pending()) Gtk::Main::iteration() ;
// warum sowas? siehe Zauber.pgcc
       list_All.push_back(&*(cH_Waffe(&*i)));
    }
 }
#endif
 progressbar->set_percentage(1);
}
