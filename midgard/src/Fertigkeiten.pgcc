/*  Midgard Character Generator
 *  Copyright (C) 2001-2002 Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include "Fertigkeiten.hh"
#include "midgard_CG.hh"
#include <Aux/SQLerror.h>
#include <Aux/Transaction.h>
#include "Typen.hh"
exec sql include sqlca;

cH_Fertigkeit::cache_t cH_Fertigkeit::cache;

cH_Fertigkeit::cH_Fertigkeit(const std::string& name)
{
 cH_Fertigkeit *cached(cache.lookup(name));
 if (cached) *this=*cached;
 else
  {
#ifndef USE_XML 
   *this=cH_Fertigkeit(new Fertigkeit(name));  
#else
  cerr << "Fertigkeit '" << name << "' nicht im Cache\n";
  *this=cH_Fertigkeit(find_Tag("Fertigkeiten","Fertigkeit","Name",name));
#endif
   cache.Register(name,*this);
  }
}

#ifdef USE_XML
cH_Fertigkeit::cH_Fertigkeit(const Tag *tag)
{if (!tag) throw NotFound();
//assert(tag);
 *this=cH_Fertigkeit(new Fertigkeit(tag));
 cache.Register(tag->getAttr("Name"),*this);
}
#endif

void Fertigkeit::get_Fertigkeit()
{
#ifndef USE_XML
  exec sql begin declare section;
   int db_lp,db_lp_l,db_lp_s,db_anfangswert0,db_anfangswert,db_ungelernt,
         db_kosten,db_berufskategorie;
   int db_st,db_gw,db_gs,db_ko,db_in,db_zt,db_pa,db_au,db_sb,db_rw;
   int db_maxwert,db_maxunter;
   char query[1024],db_region[10],db_attribut[10],db_voraussetzung[50];
  exec sql end declare section; 
  std::string squery ="select lp,coalesce(lp_land,99),coalesce(lp_stadt,99),coalesce(anfangswert0,0),
      coalesce(anfangswert,0),coalesce(ungelernt,-1),coalesce(berufsklasse,0),
      maxwert,maxunterweisung,
      coalesce(fp,0),coalesce(region,''),
      coalesce(attribut,''), coalesce(st,0), coalesce(gw,0),coalesce(gs,0),
      coalesce(ko,0), coalesce(\"in\",0), coalesce(zt,0),   
      coalesce(au,0), coalesce(pa,0), 
      coalesce(sb,0), coalesce(rw,0), coalesce(v.fertigkeit,'')
      from fertigkeiten f, fertigkeiten_voraussetzung v
      where f.fertigkeit = '"+Name()+"' and f.fertigkeit = v.name";

  strncpy(query,squery.c_str(),sizeof(query));
  Transaction tr;
  exec sql prepare cl_fertigkeit_ein_ from :query ;
  exec sql declare cl_fertigkeit_ein cursor for cl_fertigkeit_ein_ ;

  exec sql open cl_fertigkeit_ein;
  SQLerror::test(__FILELINE__);
  exec sql fetch cl_fertigkeit_ein into :db_lp,:db_lp_l,:db_lp_s, 
      :db_anfangswert0, :db_anfangswert, :db_ungelernt, :db_berufskategorie, 
      :db_maxwert,:db_maxunter,:db_kosten, :db_region,
      :db_attribut, :db_st,:db_gw,:db_gs,:db_ko,:db_in,:db_zt,:db_au,:db_pa,
      :db_sb,:db_rw, :db_voraussetzung;
  SQLerror::test(__FILELINE__);
 lern_unge=db_lp;
 lern_land=db_lp_l;
 lern_stadt=db_lp_s;
 maxunterweisung=db_maxunter;
 maxerfolgswert=db_maxwert;
  anfangswert0=db_anfangswert0;
  anfangswert=db_anfangswert;
  ungelernt=db_ungelernt;
  berufskategorie=db_berufskategorie;
  erfolgswert=anfangswert; //Defaultwert
  kosten=db_kosten;
  region=db_region;
//cout << Name()<<'\t'<<db_region <<' ' <<Region()<<'\n';
  attribut=db_attribut;
  voraussetzung = st_Voraussetzung(db_st,db_gw,db_gs,db_ko,db_in,db_zt,db_au,db_pa,
                                   db_sb,db_rw,db_voraussetzung);
  exec sql close cl_fertigkeit_ein;
#else
  assert(tag);
  lernpunkte=tag->getIntAttr("Lernpunkte",99); // außergewöhnliche Fertigkeit
  lern_land=tag->getIntAttr("Lernpunkte-Land",99);
  lern_stadt=tag->getIntAttr("Lernpunkte-Stadt",99);
  anfangswert0=tag->getIntAttr("Anfangswert");
  anfangswert=tag->getIntAttr("Erfolgswert");
  ungelernt=tag->getIntAttr("Erfolgswert-ungelernt");
  berufskategorie=tag->getIntAttr("Berufskategorie");
  erfolgswert=anfangswert; //Defaultwert
  kosten=tag->getIntAttr("Lernkosten");
  region=tag->getAttr("Region");
  attribut=tag->getAttr("Attribut");
  const Tag *Voraussetzungen=tag->find("Voraussetzungen");
  if (Voraussetzungen)
     voraussetzung = st_Voraussetzung(Voraussetzungen->getIntAttr("St"),
     		Voraussetzungen->getIntAttr("Gw",Voraussetzungen->getIntAttr("RW")),
     		Voraussetzungen->getIntAttr("Gs",Voraussetzungen->getIntAttr("Ge")),
     		Voraussetzungen->getIntAttr("Ko"),
     		Voraussetzungen->getIntAttr("In"),
     		Voraussetzungen->getIntAttr("Zt"),
     		Voraussetzungen->getIntAttr("Au"),
     		Voraussetzungen->getIntAttr("pA"),
                Voraussetzungen->getIntAttr("Sb"),
                Voraussetzungen->getIntAttr("RW"),
                Voraussetzungen->getAttr("Fertigkeit"));
#endif  
}

bool Fertigkeit::Voraussetzungen(const Grundwerte& Werte) const 
{
 if ( voraussetzung.st<=Werte.St() &&
      voraussetzung.gw<=Werte.Gw() &&
      voraussetzung.gs<=Werte.Gs() &&
      voraussetzung.ko<=Werte.Ko() &&
      voraussetzung.in<=Werte.In() &&
      voraussetzung.zt<=Werte.Zt() &&
      voraussetzung.au<=Werte.Au() &&
      voraussetzung.pa<=Werte.pA() &&
      voraussetzung.sb<=Werte.Sb()
     )   
    return true;
 else return false ;
}

int Fertigkeit::FErfolgswert(const Grundwerte &Werte) const
{
  if(Name()!="Trinken") return Erfolgswert();
  else return Erfolgswert()+Werte.Ko()/10;
}

int Fertigkeit::MaxErfolgswert(const Grundwerte& w,const vector<cH_Typen>& Typ) const
{
  return maxerfolgswert + AttributBonus(w);
}



int Fertigkeit::AttributBonus(const Grundwerte& Werte) const
{
   int b=0;
   if (Attribut()=="St" && Werte.St()>=81) ++b;
   if (Attribut()=="St" && Werte.St()>=96) ++b;
   if (Attribut()=="Gw" && Werte.Gw()>=81) ++b;
   if (Attribut()=="Gs" && Werte.Gs()>=96) ++b;
   if (Attribut()=="Ko" && Werte.Ko()>=81) ++b;
   if (Attribut()=="Ko" && Werte.Ko()>=96) ++b;
   if (Attribut()=="In" && Werte.In()>=81) ++b;
   if (Attribut()=="In" && Werte.In()>=96) ++b;
   if (Attribut()=="Zt" && Werte.Zt()>=81) ++b;
   if (Attribut()=="Zt" && Werte.Zt()>=96) ++b;
   if (Attribut()=="Sb" && Werte.Sb()>=81) ++b;
   if (Attribut()=="Sb" && Werte.Sb()>=96) ++b;
   if (Attribut()=="pA" && Werte.pA()>=81) ++b;
   if (Attribut()=="pA" && Werte.pA()>=96) ++b;
 return b;
}

Fertigkeiten_All::Fertigkeiten_All(Gtk::ProgressBar *progressbar)
{
#ifndef USE_XML
 exec sql begin declare section;
   char db_name[50][100];
   int db_size;
 exec sql end declare section;
 exec sql select count(fertigkeit) into :db_size from fertigkeiten;
 exec sql declare FIein cursor for select distinct fertigkeit from fertigkeiten;
 Transaction tr;
 exec sql open FIein;
 SQLerror::test(__FILELINE__);
 double count=0;  
 while(true)   
  {
//   progressbar->set_percentage(count/db_size);
//   while(Gtk::Main::events_pending()) Gtk::Main::iteration() ;
   exec sql fetch 50 in FIein into :db_name;
   SQLerror::test(__FILELINE__,100);  
//   if (sqlca.sqlcode) break;
   int j=sqlca.sqlerrd[2];
   for (int i=0;i<j;++i)
    {
      progressbar->set_percentage(count/db_size);
      while(Gtk::Main::events_pending()) Gtk::Main::iteration() ;
//      list_All.push_back(new Fertigkeit(db_name[i]));
//      list_All.push_back(&**(new const cH_Fertigkeit(db_name[i])));
      list_All.push_back(&*(cH_Fertigkeit(db_name[i])));
      ++count;
    }
   if(j<50) break;
  }
 exec sql close FIein;
 tr.close();
#else
 const Tag *fertigkeiten=xml_data->find("Fertigkeiten");
 int count=0;
 if (!fertigkeiten)
    cerr << "<Fertigkeiten><Fertigkeit/>... nicht gefunden\n";
 else
 {  Tag::const_iterator b=fertigkeiten->begin(),e=fertigkeiten->end();
    double size=e-b;
    for (Tag::const_iterator i=fertigkeiten->find(b,"Fertigkeit");
    		i!=e;	i=fertigkeiten->find(i+1,"Fertigkeit"))
    {  if (!((++count)&31))
       {  progressbar->set_percentage((i-b)/size);
          while(Gtk::Main::events_pending()) Gtk::Main::iteration() ;
       }
// warum sowas?
//    die Klasse cH_Fertigkeit enthält den Cache, erzeuge ich nur eine Fertigkeit, so
//    wird sie nicht in den Cache (nach Namen) aufgenommen.
//    Ich brauche aber einen cH_MidgardBasicElement, daher bilde ich einen
//    Fertigkeit* um danach (aus dem ebenfalls MidgardBasicElement*) ein 
//    cH_MidgardBasicElement zu machen. Wow.
       list_All.push_back(&*(cH_Fertigkeit(&*i)));
    }
 }
#endif
 progressbar->set_percentage(1);
}  


