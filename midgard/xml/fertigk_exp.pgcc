// $Id: fertigk_exp.pgcc,v 1.18 2001/11/21 11:04:13 christof Exp $
/*  Midgard Roleplaying Character Generator
 *  Copyright (C) 2001 Christof Petig
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <fstream>
#include <Aux/Transaction.h>
#include <Aux/dbconnect.h>
exec sql include sqlca;
#include "export_common.h"
#include <Aux/itos.h>

// wegen eines bugs in epcg <=V6.1
#define GARNIX 

void fert_speichern(std::ostream &o)
{  
   Transaction t;
   exec sql allocate descriptor spalten;
   exec sql declare fert_curs cursor for
   	select fertigkeit, region, 
   		lp as lernpunkte, anfangswert0, fp, anfangswert, attribut
   	from fertigkeiten
   	order by region,fertigkeit;
   exec sql open fert_curs;
   SQLerror::test(__FILELINE__);
   o << " <Fertigkeiten>\n";
  while (true)
  {exec sql fetch fert_curs into sql descriptor spalten;
   SQLerror::test(__FILELINE__,100);
   if (sqlca.sqlcode) break;
   FetchIStream is("spalten");
   o << "  <Fertigkeit";
   string fert=fetch_and_write_string_attrib(is, o, "Name");
   fetch_and_write_string_attrib(is, o, "Region");
   fetch_and_write_int_attrib(is, o, "Lernpunkte");
   fetch_and_write_int_attrib(is, o, "Anfangswert");
   fetch_and_write_int_attrib(is, o, "Lernkosten");
   fetch_and_write_int_attrib(is, o, "Erfolgswert");
   fetch_and_write_string_attrib(is, o, "Attribut");
   o << ">\n";
   {  exec sql begin declare section;
      const char *FERTIGK=fert.c_str(GARNIX);
      char TYPEN[40][40];
      exec sql end declare section;
      
      exec sql select typ into :TYPEN from fertigkeiten_typen
      	where name=:FERTIGK and standard='G'
      	order by typ;
      if (!sqlca.sqlcode) 
      {  o << "    <Grund>";
         for (int i=0;i<sqlca.sqlerrd[2];++i)
         {  o << typ_standardisierung(TYPEN[i]);
            if (i+1 < sqlca.sqlerrd[2]) o << ',';
         }
         o << "</Grund>\n";
      }
      exec sql select typ into :TYPEN from fertigkeiten_typen
      	where name=:FERTIGK and standard='S'
      	order by typ;
      if (!sqlca.sqlcode) 
      {  o << "    <Standard>";
         for (int i=0;i<sqlca.sqlerrd[2];++i)
         {  o << typ_standardisierung(TYPEN[i]);
            if (i+1 < sqlca.sqlerrd[2]) o << ',';
         }
         o << "</Standard>\n";
      }
      exec sql select typ into :TYPEN from fertigkeiten_typen
      	where name=:FERTIGK and standard='A'
      	order by typ;
      if (!sqlca.sqlcode) 
      {  o << "    <Ausnahme>";
         for (int i=0;i<sqlca.sqlerrd[2];++i)
         {  o << typ_standardisierung(TYPEN[i]);
            if (i+1 < sqlca.sqlerrd[2]) o << ',';
         }
         o << "</Ausnahme>\n";
      }

      //********** fertigkeiten_voraussetzung **********************************
      exec sql declare cursor_vor cursor for 
      	select st,ge,ko,"in",zt,au,pa,sb,rw, fertigkeit
      	from fertigkeiten_voraussetzung
      	where name=:FERTIGK 
      	order by fertigkeit;
      exec sql open cursor_vor;
      while (!sqlca.sqlcode) 
      {  exec sql fetch from cursor_vor into sql descriptor spalten;
         if (sqlca.sqlcode) break;
         FetchIStream is2("spalten");
         o << "    <Voraussetzungen";
         fetch_and_write_int_attrib(is2, o, "St");
         fetch_and_write_int_attrib(is2, o, "Ge");
         fetch_and_write_int_attrib(is2, o, "Ko");
         fetch_and_write_int_attrib(is2, o, "In");
         fetch_and_write_int_attrib(is2, o, "Zt");
         fetch_and_write_int_attrib(is2, o, "Au");
         fetch_and_write_int_attrib(is2, o, "pA");
         fetch_and_write_int_attrib(is2, o, "Sb");
         fetch_and_write_int_attrib(is2, o, "RW");
         fetch_and_write_string_attrib(is2, o, "Fertigkeit");
         o << "/>\n";
      }
      exec sql close cursor_vor;

      //********** Lernschema **********************************
      // wert, attribut, [p+s]_element 
      exec sql declare cursor_lp cursor for 
      	select typ,lernpunkte,pflicht from lernschema 
      	where fertigkeit=:FERTIGK and art='Fertigkeit'
      	order by lernpunkte,typ;
      exec sql open cursor_lp;
      while (!sqlca.sqlcode) 
      {  exec sql fetch from cursor_lp into sql descriptor spalten;
         if (sqlca.sqlcode) break;
         FetchIStream is2("spalten");
         o << "    <Lernschema";
         fetch_and_write_typ_attrib(is2, o, "Typ");
         fetch_and_write_int_attrib(is2, o, "Lernpunkte");
         fetch_and_write_bool_attrib(is2, o, "Pflicht");
         o << "/>\n";
      }
      exec sql close cursor_lp;

      //********** Pflicht ****************
     {exec sql begin declare section;
      	 int LERNPKTE[40], ERFWERT[40];
         exec sql end declare section;
         
      exec sql select typ,coalesce(lernpunkte,0),coalesce(erfolgswert,0) 
      	into :TYPEN,:LERNPKTE,:ERFWERT from pflicht_lernen 
      	where pflicht=:FERTIGK order by typ;
      if (!sqlca.sqlcode) 
      {  for (int i=0;i<sqlca.sqlerrd[2];++i)
         {  o << "    <Lernschema";
            write_string_attrib(o,"Typ",typ_standardisierung(TYPEN[i]));
            write_int_attrib(o,"Lernpunkte",LERNPKTE[i]);
            write_int_attrib(o,"Anfangswert",ERFWERT[i]);
            write_bool_attrib(o,"Pflicht",true);
            o << "/>\n";
         }
      }
     }
      //********** Verbot ****************
     {exec sql begin declare section;
      	 char SPIELBEGINN[40][2];
         exec sql end declare section;
         
      exec sql select typ,coalesce(spielbegin,'') 
      	into :TYPEN,:SPIELBEGINN from pflicht_lernen 
      	where verboten=:FERTIGK order by typ;
      if (!sqlca.sqlcode) 
      {  for (int i=0;i<sqlca.sqlerrd[2];++i)
         {  o << "    <Verbot";
            write_string_attrib(o,"Typ",typ_standardisierung(TYPEN[i]));
            write_bool_attrib(o,"Spielbeginn",SPIELBEGINN[i]==string("S"));
            o << "/>\n";
         }
      }
     }
//************** ausnahmen *****************
      exec sql declare cursor_ausn cursor for 
      	select spezies, herkunft, typ, beruf, stand, standard
      	from ausnahmen 
      	where name=:FERTIGK and art='f'
      	order by spezies,herkunft,typ,beruf,stand;
      exec sql open cursor_ausn;
      while (!sqlca.sqlcode) 
      {  exec sql fetch from cursor_ausn into sql descriptor spalten;
         if (sqlca.sqlcode) break;
         FetchIStream is2("spalten");
         o << "    <regionaleBesonderheit";
         fetch_and_write_string_attrib(is2, o, "Spezies");
         fetch_and_write_string_attrib(is2, o, "Herkunft");
         fetch_and_write_typ_attrib(is2, o, "Typ");
         fetch_and_write_string_attrib(is2, o, "Beruf");
         fetch_and_write_string_attrib(is2, o, "Stand");
         fetch_and_write_string_attrib(is2, o, "Standard");
         o << "/>\n";
      }
      exec sql close cursor_ausn;

// ************************* Steigern wie *****************************
      {  exec sql begin declare section;
      	 char STEIGERN_WIE[100];
         exec sql end declare section;
         
         exec sql select wie into :STEIGERN_WIE 
         	from steigern_fertigkeiten
         	where name=:FERTIGK;
         if (!sqlca.sqlcode && fert!=STEIGERN_WIE)
            o << "    <steigern_wie Fertigkeit=\"" << toXML(STEIGERN_WIE) << "\"/>\n";
      }
//********************* praxispunkte ********************
      { exec sql begin declare section;
      	 int MAX_WERT,LERNFAKTOR;
         exec sql end declare section;
         
       exec sql select coalesce(max_wert,0), coalesce(lernfaktor,0)
       	into :MAX_WERT, :LERNFAKTOR
       	from praxispunkte
       	where name=:FERTIGK;
       if (!sqlca.sqlcode && (MAX_WERT || LERNFAKTOR))
       {  o << "    <Praxispunkte";
          write_int_attrib(o, "MaximalWert", MAX_WERT);
          write_int_attrib(o, "Lernfaktor", LERNFAKTOR);
          o << "/>\n";
       }
      }

//********************* steigern_fertigkeiten_werte ********************
      {  exec sql select 
      	    coalesce(p0,0), coalesce(p1,0), coalesce(p2,0), coalesce(p3,0),
      	    coalesce(p4,0), coalesce(p5,0), coalesce(p6,0), coalesce(p7,0),
      	    coalesce(p8,0), coalesce(p9,0), coalesce(p10,0), coalesce(p11,0),
      	    coalesce(p12,0), coalesce(p13,0), coalesce(p14,0), coalesce(p15,0),
      	    coalesce(p16,0), coalesce(p17,0), coalesce(p18,0), coalesce(p19,0),
      	    coalesce(p20,0), coalesce(p21,0), coalesce(p22,0), coalesce(p23,0),
      	    coalesce(p24,0), coalesce(p25,0), coalesce(p26,0), coalesce(p27,0),
      	    coalesce(p28,0)
	    	into sql descriptor spalten
       		from steigern_fertigkeiten_werte
       		where name=:FERTIGK;
       if (!sqlca.sqlcode)
       {  o << "    <Kosten";
          FetchIStream is("spalten");
          for (int i=0;i<=28;++i) 
             fetch_and_write_int_attrib(is, o, "Wert"+itos(i));
          o << "/>\n";
       }
      }

      //********** ZEP oder KEP ? ****************
     {   exec sql begin declare section;
      	 char EP[4][8];
         exec sql end declare section;
         
      exec sql select ep into :EP from steigern_fertigkeiten_mit 
      	where name=:FERTIGK order by ep;
      if (!sqlca.sqlcode) 
      {  o << "    <EP-Typ Typ=\""; 
         for (int i=0;i<sqlca.sqlerrd[2];++i)
         {  o << EP[i];
            if (i+1 < sqlca.sqlerrd[2]) o << ',';
         }
         o << "\"/>\n";
      }
     }
   }
   
   o << "  </Fertigkeit>\n";
  }
   exec sql close fert_curs;
   SQLerror::test(__FILELINE__);
   o << " </Fertigkeiten>\n";

//********************* angeborene Fertigkeiten ********************
   o << " <angeboreneFertigkeiten>\n";
   exec sql declare angeb_curs cursor for
   	select name, min, max, wert
   	from angeborene_fertigkeiten
   	order by name;
   exec sql open angeb_curs;
   SQLerror::test(__FILELINE__);
  while (true)
  {exec sql fetch angeb_curs into sql descriptor spalten;
   SQLerror::test(__FILELINE__,100);
   if (sqlca.sqlcode) break;
   FetchIStream is("spalten");
   o << "  <angeboreneFertigkeit";
   fetch_and_write_string_attrib(is, o, "Name");
   fetch_and_write_int_attrib(is, o, "Min");
   fetch_and_write_int_attrib(is, o, "Max");
   fetch_and_write_int_attrib(is, o, "Wert");
   o << "/>\n";
  }
   exec sql close angeb_curs;
   SQLerror::test(__FILELINE__);
   o << " </angeboreneFertigkeiten>\n";

//********************* Berufe ********************
   o << " <Berufe>\n";
   exec sql declare beruf_curs cursor for
   	select beruf, region, lernpunkte, st, ge, ko, "in", zt, pa, au, sb, 
   		typ, geschlecht
   	from berufe_voraussetzung
   	order by region, beruf;
   exec sql open beruf_curs;
   SQLerror::test(__FILELINE__);
  while (true)
  {exec sql fetch beruf_curs into sql descriptor spalten;
   SQLerror::test(__FILELINE__,100);
   if (sqlca.sqlcode) break;
   FetchIStream is("spalten");
   o << "  <Beruf";
   std::string beruf=fetch_and_write_string_attrib(is, o, "Name");
   fetch_and_write_string_attrib(is, o, "Region");
   fetch_and_write_int_attrib(is, o, "Lernpunkte");
   o << ">\n";
   o << "    <Voraussetzungen";
   fetch_and_write_int_attrib(is, o, "St");
   fetch_and_write_int_attrib(is, o, "Ge");
   fetch_and_write_int_attrib(is, o, "Ko");
   fetch_and_write_int_attrib(is, o, "In");
   fetch_and_write_int_attrib(is, o, "Zt");
   fetch_and_write_int_attrib(is, o, "pA");
   fetch_and_write_int_attrib(is, o, "Au");
   fetch_and_write_int_attrib(is, o, "Sb");
   fetch_and_write_typ_attrib(is, o, "Typ");
   fetch_and_write_string_attrib(is, o, "Geschlecht");
   o << "/>\n";
   {  exec sql begin declare section;
      const char *BERUF=beruf.c_str(GARNIX);
      char STAND[10][40];
      char VORTEIL[10][40];
      exec sql end declare section;
      
      exec sql select stand into :STAND from berufe_stand
      	where beruf=:BERUF
      	order by stand;
      if (!sqlca.sqlcode) 
      {  o << "    <Stand>";
         for (int i=0;i<sqlca.sqlerrd[2];++i)
         {  o << STAND[i];
            if (i+1 < sqlca.sqlerrd[2]) o << ',';
         }
         o << "</Stand>\n";
      }

      exec sql select vorteil into :VORTEIL from berufe_vorteile
      	where beruf=:BERUF
      	order by vorteil;
      if (!sqlca.sqlcode) 
      {  o << "    <Vorteil>";
         for (int i=0;i<sqlca.sqlerrd[2];++i)
         {  o << VORTEIL[i];
            if (i+1 < sqlca.sqlerrd[2]) o << ',';
         }
         o << "</Vorteil>\n";
      }
      //********** Pflicht ****************
     {exec sql begin declare section;
      	 int LERNPKTE[40], ERFWERT[40];
      	 char TYPEN[40][40];
         exec sql end declare section;
         
      exec sql select typ,coalesce(lernpunkte,0),coalesce(erfolgswert,0) 
      	into :TYPEN,:LERNPKTE,:ERFWERT from pflicht_lernen 
      	where pflicht=:BERUF order by typ;
      if (!sqlca.sqlcode) 
      {  for (int i=0;i<sqlca.sqlerrd[2];++i)
         {  o << "    <Lernschema";
            write_string_attrib(o,"Typ",typ_standardisierung(TYPEN[i]));
            write_int_attrib(o,"Lernpunkte",LERNPKTE[i]);
            write_int_attrib(o,"Anfangswert",ERFWERT[i]);
            write_bool_attrib(o,"Pflicht",true);
            o << "/>\n";
         }
      }
     }
      //********** Verbot ****************
     {exec sql begin declare section;
      	 char SPIELBEGINN[40][2];
      	 char TYPEN[40][40];
         exec sql end declare section;
         
      exec sql select typ,coalesce(spielbegin,'') 
      	into :TYPEN,:SPIELBEGINN from pflicht_lernen 
      	where verboten=:BERUF order by typ;
      if (!sqlca.sqlcode) 
      {  for (int i=0;i<sqlca.sqlerrd[2];++i)
         {  o << "    <Verbot";
            write_string_attrib(o,"Typ",typ_standardisierung(TYPEN[i]));
            write_bool_attrib(o,"Spielbeginn",SPIELBEGINN[i]==string("S"));
            o << "/>\n";
         }
      }
     }
   }
   o << "  </Beruf>\n";
  }
   exec sql close beruf_curs;
   SQLerror::test(__FILELINE__);
   o << " </Berufe>\n";

//********************* Pflicht + verboten ********************
   o << " <Typ-Pflichten>\n";
   o << "    <-- hier stehen nur die Dinge, die nicht schon Fertigkeiten/Berufe sind -->\n";
   exec sql declare pflicht_curs cursor for
   	select pflicht, typ, lernpunkte, verboten, spielbegin, erfolgswert
   	from pflicht_lernen
   	where not exists (select true from fertigkeiten 
   		where pflicht=fertigkeit or verboten=fertigkeit)
   	and not exists (select true from berufe_voraussetzung 
   		where pflicht=beruf or verboten=beruf)
   	order by typ,coalesce(pflicht,''),verboten;
   exec sql open pflicht_curs;
   SQLerror::test(__FILELINE__);
  while (true)
  {exec sql fetch pflicht_curs into sql descriptor spalten;
   SQLerror::test(__FILELINE__,100);
   if (sqlca.sqlcode) break;
   FetchIStream is("spalten");
   std::string pflicht=fetch_string(is);
   if (pflicht.size())
   {  o << "  <Pflicht";
      fetch_and_write_string_attrib(is, o, "Typ");
      write_string_attrib(o, "Fertigkeit", pflicht);
      fetch_and_write_int_attrib(is, o, "Lernpunkte");
      fetch_string(is);
      fetch_and_write_string_attrib(is, o, "Spielbeginn");
      fetch_and_write_int_attrib(is, o, "Erfolgswert");
      o << "/>\n";
   }
   else
   {  o << "  <Verbot";
      fetch_and_write_string_attrib(is, o, "Typ");
      fetch_int(is);
      fetch_and_write_string_attrib(is, o, "Fertigkeit");
      fetch_and_write_string_attrib(is, o, "Spielbeginn");
      o << "/>\n";
   }
  }
   exec sql close pflicht_curs;
   SQLerror::test(__FILELINE__);
   o << " </Typ-Pflichten>\n";

//********************* praxispunkte ********************
   o << " <Praxispunkte>\n";
   exec sql declare praxis_curs cursor for
   	select name, max_wert, lernfaktor
   	from praxispunkte
   	where not exists (select true from fertigkeiten where name=fertigkeit)
   	order by name;
   exec sql open praxis_curs;
   SQLerror::test(__FILELINE__);
  while (true)
  {exec sql fetch praxis_curs into sql descriptor spalten;
   SQLerror::test(__FILELINE__,100);
   if (sqlca.sqlcode) break;
   FetchIStream is("spalten");
   o << "  <Steigern";
   fetch_and_write_string_attrib(is, o, "Name");
   fetch_and_write_int_attrib(is, o, "MaximalWert");
   fetch_and_write_int_attrib(is, o, "Lernfaktor");
   o << "/>\n";
  }
   exec sql close praxis_curs;
   SQLerror::test(__FILELINE__);
   o << " </Praxispunkte>\n";

//********************* ZEP oder KEP oder beides? ********************
  {o << " <verwendbareEP>\n";
   o << "    <-- hier stehen nur die Dinge, die nicht schon Fertigkeiten sind -->\n";
   exec sql declare mit_curs cursor for
   	select name, ep
   	from steigern_fertigkeiten_mit
   	where not exists (select true from fertigkeiten where name=fertigkeit)
   	order by name,ep;
   exec sql open mit_curs;
   SQLerror::test(__FILELINE__);
   std::string fert,ep;
  while (true)
  {exec sql begin declare section;
   char NAME[100];
   char EP[8];
   exec sql end declare section;
   
   exec sql fetch mit_curs into :NAME, :EP;
   SQLerror::test(__FILELINE__,100);
   if (sqlca.sqlcode) break;
   if (fert!=NAME)
   {  if (ep.size())
         o << "  <EP-Typ Fertigkeit=\"" << toXML(fert) 
      		<< "\" Typ=\"" << toXML(ep.substr(1)) << "\"/>\n";
      fert=NAME;
      ep="";
   }
   ep+=string(",")+EP;
  }
  if (ep.size()) 
         o << "  <EP-Typ Fertigkeit=\"" << toXML(fert) 
      		<< "\" Typ=\"" << toXML(ep.substr(1)) << "\"/>\n";
 }
   exec sql close mit_curs;
   SQLerror::test(__FILELINE__);
   o << " </verwendbareEP>\n";

//*************************** Steigerungstabelle *******************
   o << " <SteigernKosten>\n";
   exec sql declare curs_steig cursor for
      		select name,
      	    coalesce(p0,0), coalesce(p1,0), coalesce(p2,0), coalesce(p3,0),
      	    coalesce(p4,0), coalesce(p5,0), coalesce(p6,0), coalesce(p7,0),
      	    coalesce(p8,0), coalesce(p9,0), coalesce(p10,0), coalesce(p11,0),
      	    coalesce(p12,0), coalesce(p13,0), coalesce(p14,0), coalesce(p15,0),
      	    coalesce(p16,0), coalesce(p17,0), coalesce(p18,0), coalesce(p19,0),
      	    coalesce(p20,0), coalesce(p21,0), coalesce(p22,0), coalesce(p23,0),
      	    coalesce(p24,0), coalesce(p25,0), coalesce(p26,0), coalesce(p27,0),
      	    coalesce(p28,0)
       		from steigern_fertigkeiten_werte
   	where not exists (select true from fertigkeiten where name=fertigkeit)
       		order by name;
   exec sql open curs_steig;
   SQLerror::test(__FILELINE__);
   std::string fert,ep;
  while (true)
       {  exec sql fetch curs_steig into sql descriptor spalten;
          SQLerror::test(__FILELINE__,100);
          if (sqlca.sqlcode) break;
          FetchIStream is("spalten");
          o << "    <Kosten";
          fetch_and_write_string_attrib(is, o, "Fertigkeit");
          for (int i=0;i<=28;++i) 
             fetch_and_write_int_attrib(is, o, "Wert"+itos(i));
          o << "/>\n";
       }
    exec sql close curs_steig;
    SQLerror::test(__FILELINE__);
   o << " </SteigernKosten>\n";

//******************************************************************
   
   exec sql deallocate descriptor spalten;
}

#ifndef XML_NO_MAIN
int main(int argc, char *argv[])
{  
   try{
      Petig::Connection conn;
      conn.setDbase("midgard");
      Petig::dbconnect(conn);

   std::cout << "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n\n";
   std::cout << "<MidgardCG-data>\n";
   fert_speichern(std::cout);
   std::cout << "</MidgardCG-data>\n";
   Petig::dbdisconnect();
   } catch (SQLerror &e)
   {  std::cerr << e << '\n';
   }
   return 0;
}
#endif
