/*  Midgard Character Generator
 *  Copyright (C) 2001 Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include "midgard_CG.hh"
#include <Aux/Transaction.h>
#include <Aux/SQLerror.h>
exec sql include sqlca;
#include <cstring>
//#include <Gtk_OStream.h>
//#include <algorithm>
#include "WindowInfo.hh"
#include <Aux/EntryValueIntString.h>
#include <Aux/EntryValueEmptyInt.h>
#include "class_Ausnahmen.hh"


void midgard_CG::on_fertigkeiten_laden_clicked()
{
  midgard_CG::on_speichern_clicked();
  midgard_CG::show_alte_fertigkeiten();
  midgard_CG::show_neue_fertigkeiten();
}


void midgard_CG::on_leaf_selected_alte_fert(cH_RowDataBase d)
{  const Data_fert *dt=dynamic_cast<const Data_fert*>(&*d);
   on_steigern_fert_tree_alt_select(dt->Name(),dt->Erfolgswert(),dt->Steigern(),
      dt->Reduzieren(),dt->Verlernen());
}
 

void midgard_CG::show_alte_fertigkeiten()
{
   std::vector<cH_RowDataBase> datavec;
   for ( std::vector<H_Data_fert>::iterator i=vec_Fertigkeiten.begin();i!=vec_Fertigkeiten.end();++i)
      {
        exec sql begin declare section;
          int db_steigern=0, db_reduzieren=0, db_verlernen;
          char query[1024];
          char db_standard[5],db_standard2[5];
        exec sql end declare section;
        std::string squery;

        if ((*i)->Erfolgswert() != 0) // Fertigkeiten MIT Erfolgswert
         {
           squery = "SELECT coalesce(p"+itos(abs((*i)->Erfolgswert()))
               +",0),coalesce(p"+itos(abs((*i)->Erfolgswert()+1))+",0),fp,f."+Typ.Short();
           if (Typ2.Short()!="") squery += ", "+Typ2.Short();
           squery +=" FROM steigern_fertigkeiten s, steigern_fertigkeiten_werte w, \
               fertigkeiten f WHERE s.name = '"+(*i)->Name()+"' AND w.name = s.wie \
               AND f.fertigkeit = '"+(*i)->Name()+"'";
         }
        else // Fertigkeiten OHNE Erfolgswert
         {
           squery = "SELECT fp,f."+Typ.Short();
           if (Typ2.Short()!="") squery += ", "+Typ2.Short();
           squery  +=" FROM steigern_fertigkeiten s, fertigkeiten f \
               WHERE s.name = '"+(*i)->Name()+"' \
               AND f.fertigkeit = '"+(*i)->Name()+"'";
         }
        strncpy(query,squery.c_str(),sizeof(query));

        Transaction tr;
        exec sql prepare kosten_ein_ from :query ;  
        exec sql declare kosten_ein cursor for kosten_ein_ ;  
        exec sql open kosten_ein;
        if(Typ2.Short()!="")      
         {
           if ((*i)->Erfolgswert() != 0) // Fertigkeiten MIT Erfolgswert
               exec sql fetch kosten_ein into :db_reduzieren, 
                    :db_steigern, :db_verlernen, :db_standard,:db_standard2;
           else // Fertigkeiten OHNE Erfolgswert
               exec sql fetch kosten_ein into :db_verlernen, :db_standard,:db_standard2;
         }
        else
         {
           if ((*i)->Erfolgswert() != 0) // Fertigkeiten MIT Erfolgswert
               exec sql fetch kosten_ein into :db_reduzieren, 
                    :db_steigern, :db_verlernen, :db_standard;
           else // Fertigkeiten OHNE Erfolgswert
               exec sql fetch kosten_ein into :db_verlernen, :db_standard;
         }
        SQLerror::test(__FILELINE__);
        exec sql close kosten_ein;
        tr.close();

        double fac = midgard_CG::get_standard_fertigkeit_(db_standard,db_standard2,(*i)->Name());
        if (db_reduzieren !=0) db_verlernen = 0 ;
        datavec.push_back(new Data_fert((*i)->Name(),
                  (*i)->Erfolgswert(),db_steigern*fac,
                  db_reduzieren*fac,db_verlernen * fac));
      }
 alte_fert_tree->setDataVec(datavec);  
}

void midgard_CG::on_button_fertigkeiten_sort_clicked()
{
  std::deque<guint> seq = alte_fert_tree->get_seq();
  std::vector<H_Data_fert>::iterator IB=vec_Fertigkeiten.begin();
  std::vector<H_Data_fert>::iterator IE=vec_Fertigkeiten.end();
  switch((Data_fert::Spalten_A)seq[0]) {
      case Data_fert::NAMEa : stable_sort(IB,IE,Data_fert_sort_name()); ;break;
      case Data_fert::WERTa : stable_sort(IB,IE,Data_fert_sort_wert()); ;break;
      default : manage(new WindowInfo("Sortieren nach diesem Parameter\n ist nicht möglich"));
   }
}



void midgard_CG::on_leaf_selected_neue_fert(cH_RowDataBase d)
{  const Data_fert *dt=dynamic_cast<const Data_fert*>(&*d);
   on_steigern_fert_tree_neu_select(dt->Name(),dt->Erfolgswert(),dt->Lernkosten());
}


void midgard_CG::show_neue_fertigkeiten()
{
  std::vector<cH_RowDataBase> datavec;
  exec sql begin declare section;
   char db_fertigkeiten[100];
   int db_erfolgswert; 
   char db_standard[5],db_standard2[5];
   int db_fp;
   char query[1024];
   char db_voraussetzung[100];
   char db_region[10];
  exec sql end declare section;
  std::string squery = "SELECT f.fertigkeit, f.fp, coalesce(f.anfangswert,''), \
   coalesce(f."+Typ.Short()+",''), ";
  if (Typ2.Short()!="") squery += " coalesce(f."+Typ2.Short()+",''), ";
  squery += "coalesce(v.fertigkeit,''), coalesce(f.region,'') \
   FROM fertigkeiten f, fertigkeiten_voraussetzung v WHERE \
   v.name = f.fertigkeit \
   AND f.fertigkeit NOT IN (SELECT fertigkeit FROM charaktere_fertigkeiten \
   WHERE charakter_name = '"+Werte.Name_Charakter()+"' \
   AND version = '"+Werte.Version()+"') \
   AND f.fertigkeit != 'Sprache' AND f.fertigkeit != 'Lesen/Schreiben' \
   AND f.fertigkeit  not in (select verboten from pflicht_lernen where \
    typ='"+Werte.Spezies()+"'  and spielbegin is null) \
   AND fp is not null
   ORDER BY f.fertigkeit";

  strncpy(query,squery.c_str(),sizeof(query));

 Transaction tr;  
 exec sql prepare fert_ein_ from :query ;  
 exec sql declare fert_ein cursor for fert_ein_ ;  
 exec sql open fert_ein;
 SQLerror::test(__FILELINE__);
 while (true)
   {
      if (Typ2.Short()!="")
         exec sql fetch fert_ein into :db_fertigkeiten, :db_fp, 
            :db_erfolgswert, :db_standard, :db_standard2, :db_voraussetzung, 
            :db_region;
      else
         exec sql fetch fert_ein into :db_fertigkeiten, :db_fp, 
            :db_erfolgswert, :db_standard, :db_voraussetzung, 
            :db_region;
      SQLerror::test(__FILELINE__,100);  
      if (sqlca.sqlcode) break;
      double fac = midgard_CG::get_standard_fertigkeit_(db_standard,db_standard2,db_fertigkeiten);
      std::string s1 = db_standard, s2 = db_standard2;
      Ausnahmen ausnahmen(Werte,Typ,Typ2,vec_Beruf);
      s1 = ausnahmen.Ausnahmen_string(db_fertigkeiten,db_standard,"");
//std::cout << "\t\t"<<s1<<"\t"<<fac<<"\n";
//std::cout << db_fertigkeiten<<"\t"<<Fertigkeiten_Voraussetzung(db_fertigkeiten)
//      <<"\t->"<<db_region<<"<-\t"<<BRbool<<"\t"<<region_check(db_region)<<"\n";
      if (midgard_CG::Fertigkeiten_Voraussetzung(db_fertigkeiten) 
        &&midgard_CG::region_check(db_region) 
        && (s1!="" || s2!="") )
       {
          std::string st=(std::string)db_standard+" "+(std::string)db_standard2;
          datavec.push_back(new Data_fert(db_fertigkeiten,db_erfolgswert,
               db_fp*fac,st,db_voraussetzung));
       }
   }
 exec sql close fert_ein;
 neue_fert_tree->setDataVec(datavec);
 tr.commit();
}

bool midgard_CG::kido_steigern_check(int wert)
{
  if (Werte.Grad()+10 > wert) return false;
  else
   { std::string strinfo ="KiDo darf nur auf maximal Grad+10 gesteigert werden.\n";
     manage (new WindowInfo(strinfo));
     return true;
   }
}


void midgard_CG::on_steigern_fert_tree_alt_select(const std::string& fertigkeit, int wert,
   int steigern,int reduzieren,int verlernen)
{
 if (fertigkeit=="KiDo" && kido_steigern_check(wert)) return;
   if (radio_fert_steigern->get_active() && steigern)
    {
      // Steigern mit lernen
      if (!togglebutton_praxispunkte_fertigkeiten->get_active()) 
         {
            if (!midgard_CG::steigern(steigern,fertigkeit)) return;
            Werte.add_GFP(steigern);
            for (std::vector<H_Data_fert>::iterator i=vec_Fertigkeiten.begin();
                     i!= vec_Fertigkeiten.end();++i )
               if ( (*i)->Name() == fertigkeit) (*i)->set_Erfolgswert(1+(*i)->Erfolgswert()); 
         }
      else  // Lernen mit Praxispunkten 
         {
            bool wuerfeln;
            if (radiobutton_praxis_wuerfeln_fertigkeiten->get_active()) wuerfeln = true;
            if (radiobutton_praxis_auto_fertigkeiten->get_active()) wuerfeln = false;
            int gelungen = midgard_CG::praxispunkte_wuerfeln(fertigkeit,wert,"Fertigkeit",wuerfeln);
            if (gelungen)
               {
                  Werte.add_GFP(steigern/2);
                  for (std::vector<H_Data_fert>::iterator i=vec_Fertigkeiten.begin();
                        i!= vec_Fertigkeiten.end();++i )
                     if ( (*i)->Name() == fertigkeit) (*i)->set_Erfolgswert(1+(*i)->Erfolgswert()); 
               }
         }     
    }
   if (radio_fert_reduzieren->get_active() && reduzieren)
         {
            if (steigern_bool) desteigern(reduzieren);
            Werte.add_GFP(-reduzieren);
            for (std::vector<H_Data_fert>::iterator i=vec_Fertigkeiten.begin();
                     i!= vec_Fertigkeiten.end();++i )
               if ( (*i)->Name() == fertigkeit) (*i)->set_Erfolgswert((*i)->Erfolgswert()-1); 
         }
   if (radio_fert_verlernen->get_active() && verlernen)
         {
            if (steigern_bool) desteigern(verlernen);
            Werte.add_GFP(-verlernen);
            for (std::vector<H_Data_fert>::iterator i=vec_Fertigkeiten.begin();
                     i!= vec_Fertigkeiten.end();++i )
               if ( (*i)->Name() == fertigkeit) {vec_Fertigkeiten.erase(i);break;}; 
         }
   midgard_CG::zeige_werte(Werte);
   midgard_CG::on_speichern_clicked();
   midgard_CG::show_alte_fertigkeiten();
   midgard_CG::show_neue_fertigkeiten();
}

void midgard_CG::on_steigern_fert_tree_neu_select(const std::string& fertigkeit, int wert, int lernkosten)
{
  if (!steigern(lernkosten,fertigkeit)) return;
  Werte.add_GFP(lernkosten);
  midgard_CG::zeige_werte(Werte);
  vec_Fertigkeiten.push_back(new Data_fert(fertigkeit,wert));

  if (fertigkeit=="KiDo") {kido_bool=true;show_gtk();
      std::string strinfo="Jetzt muß ein Stil unter 'Lernschema' -> 'KiDo' gewählt werden !!!";
      manage (new WindowInfo(strinfo,true)); }
  if (fertigkeit=="Wissen von der Magie") 
      {  midgard_CG::doppelcharaktere();
         std::string strinfo ="Jetzt unter 'Grundwerte' die zweite Charkakterklasse wählen\n";
         manage (new WindowInfo(strinfo,true));
         // Resistenzboni für Zauberer setzten:
         Werte.set_magBoni(Werte.bo_Psy()+3,Werte.bo_Phs()+1,Werte.bo_Phk()+3);
         if (Werte.Zaubern_wert_int()==0) Werte.set_Zaubern_wert(10);
      }

  midgard_CG::show_fertigkeiten();
  midgard_CG::on_speichern_clicked();
  midgard_CG::show_alte_fertigkeiten();
  midgard_CG::show_neue_fertigkeiten();

}

void midgard_CG::on_radio_fert_steigern_toggled()
{
}



void midgard_CG::on_radio_fert_reduzieren_toggled()
{
   if (radio_fert_reduzieren->get_active())
      togglebutton_praxispunkte_fertigkeiten->set_active(false);
}

void midgard_CG::on_radio_fert_verlernen_toggled()
{
   if (radio_fert_verlernen->get_active())
      togglebutton_praxispunkte_fertigkeiten->set_active(false);
}

void midgard_CG::on_togglebutton_praxispunkte_fertigkeiten_toggled()
{
    if (togglebutton_praxispunkte_fertigkeiten->get_active())
      radio_fert_steigern->set_active(true);

}

void midgard_CG::on_radiobutton_praxis_wuerfeln_fertigkeiten_toggled()
{
}

void midgard_CG::on_radiobutton_praxis_auto_fertigkeiten_toggled()
{
}

bool midgard_CG::Fertigkeiten_Voraussetzung(const std::string& fertigkeit)
{
  exec sql begin declare section;
   int db_st,db_ge,db_ko,db_in,db_zt,db_pa,db_au,db_sb,db_rw;
   char db_fertigkeit[30], db_fert[30];
  exec sql end declare section;
  strncpy(db_fertigkeit,fertigkeit.c_str(),sizeof(db_fertigkeit));

  exec sql select distinct coalesce(st,'0'), coalesce(ge,'0'),
   coalesce(ko,'0'),  coalesce("in",'0'), coalesce(zt,'0'),
   coalesce(au,'0'), coalesce(pa,'0'), 
   coalesce(sb,'0'), coalesce(rw,'0'), coalesce(fertigkeit,'')
   into :db_st,:db_ge,:db_ko,:db_in,:db_zt,:db_au,:db_pa,
         :db_sb,:db_rw,:db_fert
   from fertigkeiten_voraussetzung where name= :db_fertigkeit;
//  SQLerror::test(__FILELINE__,100);
  SQLerror::test(__FILELINE__);
    if ( db_st<=Werte.St() &&
         db_ge<=Werte.Ge() &&
         db_ko<=Werte.Ko() &&
         db_in<=Werte.In() &&
         db_zt<=Werte.Zt() &&
         db_au<=Werte.Au() &&
         db_pa<=Werte.pA() &&
         db_sb<=Werte.Sb() &&
         db_rw<=Werte.RW()
       )   
     return true;
  else return false ;
}
